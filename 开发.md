# 爬虫

## 入门须知

### 常识

### 方法

![image-20250310200950714](../AppData/Roaming/Typora/typora-user-images/image-20250310200950714.png)

### 什么是cookie

![image-20250310201138393](../AppData/Roaming/Typora/typora-user-images/image-20250310201138393.png)

### 什么是get，什么是post

**1. HTTP 方法的本质区别**

| **方法**      | `session.get()`                              | `session.post()`                         |
| ------------- | -------------------------------------------- | ---------------------------------------- |
| **HTTP 动词** | `GET`                                        | `POST`                                   |
| **用途**      | 从服务器**获取数据**（如加载网页、查询资源） | 向服务器**提交数据**（如登录、上传文件） |
| **幂等性**    | 幂等（多次执行结果相同，如刷新页面）         | 非幂等（可能修改服务器状态，如提交订单） |

---



### 网上搜索unicode在线解码器





## scrapy

### 准备

终端创建（注意看第二张图）

![67d8b6577fe6bbc5d967dd449e6581db](C:\Users\hp\Documents\Tencent Files\1759751014\nt_qq\nt_data\Pic\2025-02\Ori\67d8b6577fe6bbc5d967dd449e6581db.png)



爬虫的名字是那个写最主要类的那个文件的名字

![d622021102ff8a42669eb45eb25dc741](../Documents/Tencent Files/1759751014/nt_qq/nt_data/Pic/2025-02/Ori/d622021102ff8a42669eb45eb25dc741.jpeg)





开管道和打开robot协议

![d599e9c53494808e847179fc332919e4](C:\Users\hp\Documents\Tencent Files\1759751014\nt_qq\nt_data\Pic\2025-02\Ori\d599e9c53494808e847179fc332919e4.png)



注意添加头文件（from大类import items里面的那个类的类名）

![image-20250225173259020](C:\Users\hp\AppData\Roaming\Typora\typora-user-images\image-20250225173259020.png)



### 操作



解释一下为什么有的时候return scrapy.Request为什么有的时候return ScrapyNcbiItem

![95a5e982-52b0-4a4b-bea1-c504edc8f80c](../AppData/Local/Temp/95a5e982-52b0-4a4b-bea1-c504edc8f80c.png)



在 `parse` 方法中，`return scrapy.Request(...)` 和 `return ScrapyNcbiItem(...)` 的不同处理方式取决于爬取逻辑的需求：

1. `return ScrapyNcbiItem(...)`：

- 这是 Scrapy 中的数据传输对象（Item）。
- 当 `t`（某个 XPath 解析结果）存在时，意味着在当前页面已经获取到目标数据，不需要进一步请求其他页面，直接构造 `ScrapyNcbiItem` 并返回，Scrapy 会将其存储或传递给 `pipelines.py` 进行处理。

2. `return scrapy.Request(...)`：

- 当 `t` 不存在，但 `a`（另一个 XPath 解析结果）存在时，说明需要访问另一个页面才能获取完整数据。
- `scrapy.Request` 创建了一个新的请求，指向新的 URL（`https://www.ncbi.nlm.nih.gov/` + `a`），并指定 `callback=self.parse_second`，表示 Scrapy 会在获取该页面后调用 `parse_second` 方法继续解析。

3. `return ScrapyNcbiItem(...)` (None 情况)：

- 如果 `t` 和 `a` 都不存在，说明当前页面没有足够信息，也没有需要进一步请求的 URL，直接返回一个 `ScrapyNcbiItem`，但 `src=None`，`officialName=None`，表示未找到有效数据。

代码逻辑总结：

1. **能直接提取数据** → 直接返回 `ScrapyNcbiItem`
2. **需要进一步访问新页面** → 返回 `scrapy.Request`
3. **既没数据也没跳转链接** → 返回 `ScrapyNcbiItem`（带 `None`）

这样可以高效地处理爬取逻辑，避免不必要的请求，同时确保数据完整性。







**可以不用extract_first()，可以直接用get()或者getall()，注意**







meta是传给下一个响应的参数，必须有meta，才能把一些东西传给下一个参数

![image-20250225194518030](../AppData/Roaming/Typora/typora-user-images/image-20250225194518030.png)



### 管道

![image-20250225194753698](../AppData/Roaming/Typora/typora-user-images/image-20250225194753698.png)



必须这样写lines，要空格必须自己中间空

![image-20250225194859571](../AppData/Roaming/Typora/typora-user-images/image-20250225194859571.png)



items必须这么写

![image-20250225195115379](../AppData/Roaming/Typora/typora-user-images/image-20250225195115379.png)



创建的Item字典

![image-20250227172314354](../AppData/Roaming/Typora/typora-user-images/image-20250227172314354.png)



### 细节

#### 如何用正则表达式匹配

![image-20250227111722493](../AppData/Roaming/Typora/typora-user-images/image-20250227111722493.png)

#### 如何DEBUG

![image-20250227142121197](../AppData/Roaming/Typora/typora-user-images/image-20250227142121197.png)



#### 写入文件快捷技巧

![image-20250227165640408](../AppData/Roaming/Typora/typora-user-images/image-20250227165640408.png)

#### 一些参数

![qq_pic_merged_1740924754134](../Downloads/qq_pic_merged_1740924754134.jpg)

箭头处是唯一去重方法



#### 传递登陆信息

![image-20250303180909095](../AppData/Roaming/Typora/typora-user-images/image-20250303180909095.png)





### IMG的Pipline

![image-20250227181136355](../AppData/Roaming/Typora/typora-user-images/image-20250227181136355.png)

这里一定要有url

![image-20250227181230495](../AppData/Roaming/Typora/typora-user-images/image-20250227181230495.png)



#### 修改

![image-20250227194037959](../AppData/Roaming/Typora/typora-user-images/image-20250227194037959.png)

注意1这里，让它不用一定要之前那个名字。也要注意这里是一个子类



这里是前面

![image-20250227193841742](../AppData/Roaming/Typora/typora-user-images/image-20250227193841742.png)



#### 特殊注意

![image-20250227201220858](../AppData/Roaming/Typora/typora-user-images/image-20250227201220858.png)

这儿可以一直传



上面的request会把meta传给下面的request

![image-20250227201919078](../AppData/Roaming/Typora/typora-user-images/image-20250227201919078.png)



### 一些操作



![image-20250301215626212](../AppData/Roaming/Typora/typora-user-images/image-20250301215626212.png)

1是从哪里传开始

2是可以下一个传给谁

3是得到什么



注意这个还有他的名字

![image-20250301220105876](../AppData/Roaming/Typora/typora-user-images/image-20250301220105876.png)



### crawl spider



创建（用下面那个命令，注意后面是domains）

![image-20250302164647093](../AppData/Roaming/Typora/typora-user-images/image-20250302164647093.png)



这里的第一个不会给parse_item

![image-20250302163948181](../AppData/Roaming/Typora/typora-user-images/image-20250302163948181.png)

**下面是修改：**

但注意这里的rules，并且parse_item最后不用传

![image-20250302163150587](../AppData/Roaming/Typora/typora-user-images/image-20250302163150587.png)

第二步：依次对 `response` 应用所有 `Rule`

在这个初始页面的 `response` 上，Scrapy 依次应用你定义的两个 `Rule`：

1. 应用第一个 Rule
   - `LinkExtractor(restrict_xpaths='//div[@id="list"]/dl/dd[2]/a')` 会在当前页面（初始页面）中，寻找符合 `//div[@id="list"]/dl/dd[2]/a` 的链接。
   - 如果找到了（比如是 “第一章”的链接），Scrapy 就会为这个链接生成一个新的 `Request`，并把它加入调度队列。这个 `Request` 的回调是 `parse_item`，并且设置了 `dont_filter=False`（默认），`follow=True`（你代码里指定了）。
2. 应用第二个 Rule
   - 同理，`LinkExtractor(restrict_xpaths='//div[@class="bottem1"]/a[4]')` 会在当前页面中寻找符合 `//div[@class="bottem1"]/a[4]` 的链接（也许是 “下一页”/“下一章”）。
   - 如果也找到了链接，就会同样生成一个新的 `Request`，加入调度队列，回调也是 `parse_item`，`follow=True`。

这样一来，**同一个页面** 上如果有两个符合规则的链接，Scrapy 就会 **同时** 为它们生成新的请求，而不是先执行完第一个 Rule 再执行第二个 Rule。它是按“依次检查每条规则 → 找到链接 → 加入队列”的方式进行。

**注意这里的rules是同时去匹配（意思是只要找到一个就会将它的链接加入到新的请求）**

![image-20250302163638991](../AppData/Roaming/Typora/typora-user-images/image-20250302163638991.png)





### 使用cookie一些特别注意

![image-20250303224220168](../AppData/Roaming/Typora/typora-user-images/image-20250303224220168.png)

**这儿的start_urls一定要是登陆后的第一个界面网址才行，而且下面也必须传它**



### 下载中间件修改UA

名字不能变。None处理下一个下载中间件，Response处理Response就不处理后面的了

![image-20250304153227469](../AppData/Roaming/Typora/typora-user-images/image-20250304153227469.png)

用别的USERAGENT

![65eea638acd013ba6dd1b0958e0c99dd](../Documents/Tencent Files/1759751014/nt_qq/nt_data/Pic/2025-03/Ori/65eea638acd013ba6dd1b0958e0c99dd.png)

注意细节，下面的要写成这样，缺一不可

![316f4eec10de99f2a9982c782511c0b7](../Documents/Tencent Files/1759751014/nt_qq/nt_data/Pic/2025-03/Ori/316f4eec10de99f2a9982c782511c0b7.png)



### ip代理

![image-20250304164716064](../AppData/Roaming/Typora/typora-user-images/image-20250304164716064.png)

这儿需要改成这样

![image-20250304164819351](../AppData/Roaming/Typora/typora-user-images/image-20250304164819351.png)



### scrapy结合selenium（就是用selenium去代替中间件）

写的时候注意这两个spider

![image-20250305192317877](../AppData/Roaming/Typora/typora-user-images/image-20250305192317877.png)

注意头文件

![image-20250305192606038](../AppData/Roaming/Typora/typora-user-images/image-20250305192606038.png)

![image-20250305192847175](../AppData/Roaming/Typora/typora-user-images/image-20250305192847175.png)



在middleware这里配置，request.url是当前网址

![image-20250305191459641](../AppData/Roaming/Typora/typora-user-images/image-20250305191459641.png)



### MongoDB

#### 启动方式

![image-20250306231811424](../AppData/Roaming/Typora/typora-user-images/image-20250306231811424.png)





![a583c8a6-9a7f-4171-a4e7-97005d3ee2a5](../AppData/Local/Temp/a583c8a6-9a7f-4171-a4e7-97005d3ee2a5.png)

#### DB基础命令

![image-20250307171823399](../AppData/Roaming/Typora/typora-user-images/image-20250307171823399.png)

创建集合

![image-20250307172818409](../AppData/Roaming/Typora/typora-user-images/image-20250307172818409.png)









#### 修改数据

query更新谁，update更新成什么样子

![qq_pic_merged_1741338600582](../Downloads/qq_pic_merged_1741338600582.jpg)

1改了之后会全改

2改了之后，因为加了key，所以只会改那一个

3是修改多个同name数据





#### 增加数据

区别：insert时，如果id相同会报错，save时，id相同会更新之前那个相同id的内容

![image-20250307165201637](../AppData/Roaming/Typora/typora-user-images/image-20250307165201637.png)

操作

![image-20250307170022211](../AppData/Roaming/Typora/typora-user-images/image-20250307170022211.png)

#### 删除和查找

![image-20250307171328562](../AppData/Roaming/Typora/typora-user-images/image-20250307171328562.png)

删除这一个所加参数justOne

![image-20250307171516730](../AppData/Roaming/Typora/typora-user-images/image-20250307171516730.png)

查找

![image-20250307201230007](../AppData/Roaming/Typora/typora-user-images/image-20250307201230007.png)

![image-20250307201136019](../AppData/Roaming/Typora/typora-user-images/image-20250307201136019.png)

![image-20250307201553116](../AppData/Roaming/Typora/typora-user-images/image-20250307201553116.png)

![image-20250307202203230](../AppData/Roaming/Typora/typora-user-images/image-20250307202203230.png)

![image-20250307202333091](../AppData/Roaming/Typora/typora-user-images/image-20250307202333091.png)

![image-20250307202546533](../AppData/Roaming/Typora/typora-user-images/image-20250307202546533.png)

#### 聚合

**1有显示与不显示，生效与不生效的作用**



![image-20250307202833290](../AppData/Roaming/Typora/typora-user-images/image-20250307202833290.png)

这是模板，注意画红线的是倍数

![image-20250307203950968](../AppData/Roaming/Typora/typora-user-images/image-20250307203950968.png)

![image-20250307204213308](../AppData/Roaming/Typora/typora-user-images/image-20250307204213308.png)

匹配过滤

![image-20250307204606449](../AppData/Roaming/Typora/typora-user-images/image-20250307204606449.png)



project筛选(在显示时，0和1共存时，0只能显示在id上)

![image-20250307211656043](../AppData/Roaming/Typora/typora-user-images/image-20250307211656043.png)

![image-20250307212128413](../AppData/Roaming/Typora/typora-user-images/image-20250307212128413.png)

![image-20250307212323664](../AppData/Roaming/Typora/typora-user-images/image-20250307212323664.png)

#### 索引

创建方法

![image-20250309001717928](../AppData/Roaming/Typora/typora-user-images/image-20250309001717928.png)

**索引读更快，但是写入更慢**

![image-20250309003715151](../AppData/Roaming/Typora/typora-user-images/image-20250309003715151.png)

利用索引去重

![image-20250309004249930](../AppData/Roaming/Typora/typora-user-images/image-20250309004249930.png)

#### python里不同



排序

![image-20250309172840104](../AppData/Roaming/Typora/typora-user-images/image-20250309172840104.png)

#### scrapy的写入数据库注意事项

python的写法

![image-20250310195504337](../AppData/Roaming/Typora/typora-user-images/image-20250310195504337.png)



1这里写入不了MongoPipeline，也写入不了下面那个MysqlPipeline

2这里return后，会给setting里的下一个Pipeline，不return item的话就只会在当前这个Pipeline持续写入

![image-20250309200822746](../AppData/Roaming/Typora/typora-user-images/image-20250309200822746.png)

![image-20250309201637317](../AppData/Roaming/Typora/typora-user-images/image-20250309201637317.png)





### scrapy的fake-useragent

登陆PyPi，然后在里面找scrapyfake-useragent，找一个，然后复制到downloadMiddleware里

### 注意反爬

**而且get()这个方法太万能了，要注意**

![image-20250309174655926](../AppData/Roaming/Typora/typora-user-images/image-20250309174655926.png)

上面可以加Referer

下面这个可以直接获取全文，然后逐步获取json里的数据，注意要用get获取



### Splash的运用

#### 属性

![image-20250327173746135](../AppData/Roaming/Typora/typora-user-images/image-20250327173746135.png)

**方法：**

寻找网址

![image-20250327173925317](../AppData/Roaming/Typora/typora-user-images/image-20250327173925317.png)

等

![image-20250327174054695](../AppData/Roaming/Typora/typora-user-images/image-20250327174054695.png)

调用js的方法

![image-20250327174310398](../AppData/Roaming/Typora/typora-user-images/image-20250327174310398.png)

其他方法

![image-20250327174456432](../AppData/Roaming/Typora/typora-user-images/image-20250327174456432.png)

![image-20250327174555794](../AppData/Roaming/Typora/typora-user-images/image-20250327174555794.png)

![image-20250327174626851](../AppData/Roaming/Typora/typora-user-images/image-20250327174626851.png)

![image-20250327174715979](../AppData/Roaming/Typora/typora-user-images/image-20250327174715979.png)

![image-20250327174857495](../AppData/Roaming/Typora/typora-user-images/image-20250327174857495.png)

![image-20250327174947414](../AppData/Roaming/Typora/typora-user-images/image-20250327174947414.png)

#### 与python结合

![image-20250327175156423](../AppData/Roaming/Typora/typora-user-images/image-20250327175156423.png)

实例

![image-20250327180351370](../AppData/Roaming/Typora/typora-user-images/image-20250327180351370.png)



### 反反爬

验证码用超级鹰



















### 讲讲request.Session

#### **`requests.Session` 的核心作用**

1. **保持会话状态**  
   在同一个 `Session` 实例中发起的多个请求会**自动共享 Cookies、Headers 等参数**，无需手动管理（例如登录后保持会话状态）。

2. **复用 TCP 连接**  
   `Session` 会复用底层的 TCP 连接，提升高频请求的性能（减少重复建立连接的开销）。

3. **统一配置**  
   可以预先为 `Session` 设置公共参数（如 Headers、代理、认证信息等），后续所有请求自动继承这些配置。

---

#### **`Session` vs 普通请求**

假设你需要向某个网站发送多个请求：
- **普通请求**（直接使用 `requests.get()` 或 `requests.post()`）：  
  每次请求都是独立的，不会共享 Cookies 或连接，需要手动处理会话状态。
  ```python
  # 每次请求都是独立的，无法自动传递 Cookies
  response1 = requests.get("https://example.com/login")
  response2 = requests.get("https://example.com/dashboard")  # 可能无法保持登录状态
  ```

- **使用 `Session`**：  
  通过 `Session` 对象发起请求，自动管理会话相关的参数。
  ```python
  import requests
  
  # 创建会话对象
  session = requests.Session()
  
  # 登录（自动保存 Cookies）
  login_data = {"username": "user", "password": "pass"}
  session.post("https://example.com/login", data=login_data)
  
  # 后续请求自动携带登录后的 Cookies
  response = session.get("https://example.com/dashboard")  # 保持登录状态
  ```

---

#### **`Session` 的常见用途**

1. **处理需要登录的网站**  
   ```python
   session = requests.Session()
   session.post(login_url, data=credentials)  # 登录
   session.get(protected_page_url)           # 访问需要登录的页面
   ```

2. **统一设置 Headers 或代理**  
   ```python
   session = requests.Session()
   session.headers.update({"User-Agent": "My Custom Agent"})  # 所有请求自动携带此 Header
   session.proxies = {"http": "http://10.10.1.10:3128"}       # 统一设置代理
   ```

3. **高频请求优化性能**  
   复用 TCP 连接，减少延迟（适合爬虫或 API 调用）。

4. **文件上传或复杂请求**  
   通过 `Session` 保持上下文，处理多步骤操作（如先获取令牌再提交数据）。

---

#### **`Session` 的底层原理**

- **Cookie 持久化**：自动处理服务器返回的 Cookies，并在后续请求中携带。
- **连接池管理**：默认复用 TCP 连接，通过 `urllib3` 库实现连接池。
- **上下文管理器**：可以用 `with` 语句自动关闭会话（推荐写法）：
  ```python
  with requests.Session() as session:
      session.get("https://example.com")
  ```

---

#### **代码示例**

```python
import requests

# 创建会话对象，并设置公共 Headers
session = requests.Session()
session.headers = {
    "User-Agent": "Mozilla/5.0",
    "Accept-Language": "en-US"
}

# 登录操作（保存 Cookies）
login_url = "https://example.com/login"
response = session.post(login_url, data={"user": "admin", "pass": "123"})

# 访问需要登录的页面（自动携带 Cookies）
profile_url = "https://example.com/profile"
response = session.get(profile_url)
print(response.text)  # 输出登录后的页面内容
```

## js逆向

#### 注意抓包

用request直接访问所需网址（用检查去查找）







#### debug寻找所需，这种方法是直接找所需要的数据是怎么生成的（在初级找信息不行时）

第一种方式是直接找是哪个属性包含我所需要的东西（直接找，然后debug）

![image-20250416200947459](../AppData/Roaming/Typora/typora-user-images/image-20250416200947459.png)

第二种打断点方式是点右边（看他是通过什么加载，如点击）

![image-20250416201527202](../AppData/Roaming/Typora/typora-user-images/image-20250416201527202.png)



#### 自己js渲染代码

![image-20250416210137927](../AppData/Roaming/Typora/typora-user-images/image-20250416210137927.png)

#### 直接在网络里找js信息，进行抓包





#### 逆向须知

人家给我们加密了，所以我们传的时候也要加密

![image-20250416210827276](../AppData/Roaming/Typora/typora-user-images/image-20250416210827276.png)



注意这里的快捷方式

![image-20250416212438675](../AppData/Roaming/Typora/typora-user-images/image-20250416212438675.png)











# Python基础

## 常识

### 图片

![image-20250413203601315](../AppData/Roaming/Typora/typora-user-images/image-20250413203601315.png)

### ./的含义

![image-20250617000305646](../AppData/Roaming/Typora/typora-user-images/image-20250617000305646.png)

### ../和./的意思

在Python和Java中， ./  和  ../  并非编程语言本身的语法，而是文件系统的通用路径符号，含义在两种语言中完全一致，用于定位文件或目录的位置。

-  ./ ：表示当前工作目录，即代码运行时所在的目录。
- 示例：在Python中使用  open("./test.txt") ，或在Java中使用  new File("./test.txt") ，都是指读取当前运行目录下的  test.txt  文件。
-  ../ ：表示上一级目录，即当前工作目录的父目录。
- 示例：在Python中使用  open("../data/test.txt") ，或在Java中使用  new File("../data/test.txt") ，都是指读取当前运行目录的上一级目录中  data  文件夹下的  test.txt  文件。









### 如何在不同操作系统环境下路径统一

这行代码 `persist_path = Path(persist_dir).expanduser().resolve()` 使用了 Python 的 `pathlib` 模块来处理文件系统路径，主要完成三个关键操作：

### 1. `Path(persist_dir)`

- **功能**：将字符串路径转换为 `Path` 对象
- **作用**：将输入的路径字符串（如 `"~/my_data"` 或 `"../data"`) 转换为面向对象的路径对象
- **示例**：`Path("~/documents")` → 创建表示该路径的对象

### 2. `.expanduser()`

- **功能**：展开波浪符 `~` 为用户主目录
- **作用**：将 `~` 替换为当前用户的主目录绝对路径
- **示例**：
  - Linux/macOS：`~/data` → `/home/username/data`
  - Windows：`~\Documents` → `C:\Users\username\Documents`

### 3. `.resolve()`

- **功能**：解析路径为绝对路径并标准化
- **作用**：
  - 将相对路径转为绝对路径（基于当前工作目录）
  - 解析所有符号链接（如果有）
  - 规范化路径（移除冗余的 `..`、`.` 等）
- **示例**：
  - `../data` → `/project/data`（假设当前在 `/project/src`）
  - `./config/../data` → `/project/data`

### 为什么需要这行代码？

1. **路径一致性**：确保不同操作系统/环境下路径格式统一
2. **防止错误**：避免因 `~` 或相对路径导致的文件位置错误
3. **安全访问**：解析符号链接防止指向意外位置
4. **可靠存储**：数据库等持久化存储需要绝对路径保证可靠性







## 小技巧

### zip

![image-20250225200141405](../AppData/Roaming/Typora/typora-user-images/image-20250225200141405.png)



### 序列解包

![image-20250225200505482](../AppData/Roaming/Typora/typora-user-images/image-20250225200505482.png)



### 字典



创建

![image-20250226195342630](../AppData/Roaming/Typora/typora-user-images/image-20250226195342630.png)

键重复了，后面的会把前面的剃掉



注意

![image-20250225201432475](../AppData/Roaming/Typora/typora-user-images/image-20250225201432475.png)



### 字典的get方法健壮性更好

1. **在代码中的应用**
   在 `web_results.get('organic', [])` 中：
   - 程序尝试从 `web_results` 字典中获取键为 `'organic'` 的值。
   - 如果存在 `'organic'` 键，返回其对应的值（通常是一个包含搜索结果的列表）。
   - 如果不存在 `'organic'` 键，则返回默认的空列表 `[]`。
2. **为什么用 `get` 而不是直接访问？**
   - **避免崩溃**：如果直接写 `web_results['organic']`，当 `'organic'` 键不存在时，程序会抛出 `KeyError` 异常。使用 `get` 可以避免这个问题。
   - **提供默认值**：当键不存在时，返回 `[]` 可以保证后续的 `for result in ...` 循环仍然能正常迭代一个空列表（相当于跳过循环，但不会报错）。









### 元组

![image-20250226194650235](../AppData/Roaming/Typora/typora-user-images/image-20250226194650235.png)



![image-20250226194734398](../AppData/Roaming/Typora/typora-user-images/image-20250226194734398.png)

### 判断一个列表是不是一个字典的某个键（他是列表）

只能用set把这个字典的键全部装入，不能直接用 in判断



### format

![image-20250226195934661](../AppData/Roaming/Typora/typora-user-images/image-20250226195934661.png)





### 格式化

![image-20250226200230693](../AppData/Roaming/Typora/typora-user-images/image-20250226200230693.png)





### 函数

![image-20250226201605289](../AppData/Roaming/Typora/typora-user-images/image-20250226201605289.png)

![image-20250226201829414](../AppData/Roaming/Typora/typora-user-images/image-20250226201829414.png)





### 变量作用域

![image-20250226202035639](../AppData/Roaming/Typora/typora-user-images/image-20250226202035639.png)

![image-20250226202213481](../AppData/Roaming/Typora/typora-user-images/image-20250226202213481.png)





### 参数传递

![image-20250226203602774](../AppData/Roaming/Typora/typora-user-images/image-20250226203602774.png)

![image-20250226204159290](../AppData/Roaming/Typora/typora-user-images/image-20250226204159290.png)

![image-20250226204902142](../AppData/Roaming/Typora/typora-user-images/image-20250226204902142.png)



### （重要）深浅拷贝理解



![image-20250226205256985](../AppData/Roaming/Typora/typora-user-images/image-20250226205256985.png)

浅拷贝

![image-20250226205849623](../AppData/Roaming/Typora/typora-user-images/image-20250226205849623.png)

深拷贝

![image-20250226210133520](../AppData/Roaming/Typora/typora-user-images/image-20250226210133520.png)



修改不可变对象中的可变对象，这个不变

![image-20250226221608531](../AppData/Roaming/Typora/typora-user-images/image-20250226221608531.png)



### 多个yield

`def count_up_to(n):`
    `count = 1`
    `while count <= n:`
        `yield count  # 第一个yield`
        `count += 1`
    `yield 'Done'  # 第二个yield，返回结束信号`

`调用该函数并遍历生成器`

`counter = count_up_to(5)`

`每次调用next()，函数从上次暂停的地方继续执行`

`print(next(counter))  # 输出 1`
`print(next(counter))  # 输出 2`
`print(next(counter))  # 输出 3`
`print(next(counter))  # 输出 4`
`print(next(counter))  # 输出 5`
`print(next(counter))  # 输出 Done`



## 异步操作

### 解决的问题

**问题**：`model.run` 是一个耗时且阻塞的函数。如果直接在 `async` 函数中调用 `model.run(...)`，它会阻塞整个事件循环，导致 FastAPI 在这段时间内无法处理其他任何请求。

### 什么是异步和阻塞

**异步**指的是程序在执行某个耗时操作时，不需要等待该操作完成，就可以继续执行后面的任务。它就像你去餐厅点餐，服务员告诉你“请稍等，餐点好了会叫你”，然后你就回到座位上喝水、聊天，而不是站在柜台前一直等。当餐点准备好后，服务员会通知你。

**阻塞**是异步的反义词。当一个操作是阻塞的，它会“霸占”当前线程，直到操作完成，后面的所有代码都必须暂停，等待它。这就像你在餐厅点餐，服务员说“你在这里等着，直到我把你的餐点做好”，于是你只能站在柜台前，什么都不能做。

在 Web 服务中，如果一个请求需要执行一个耗时的阻塞操作（比如访问数据库、调用外部 API 或进行复杂的计算），那么在等待这个操作完成期间，服务器无法处理其他用户的请求。这会导致整个服务变慢，甚至无响应。

### 异步好处

**提升并发性能：** 这是最核心的好处。在 Web 服务中，一个线程可以同时处理多个请求。当一个请求触发一个耗时操作时，该线程可以“切换”出去，去处理另一个请求，而不用闲置等待。这使得服务器能同时处理更多的用户连接，大大提高了吞吐量和响应速度。

**更好的用户体验：** 对于客户端应用（比如移动 App 或桌面程序），异步操作可以防止界面“冻结”。耗时任务在后台运行，主界面线程可以继续响应用户的点击、滑动等操作，提供流畅的用户体验。

**资源利用率更高：** 在 I/O 密集型任务（如网络请求、文件读写）中，线程通常大部分时间处于空闲等待状态。异步编程模型能更有效地利用这些空闲时间，让一个线程完成更多工作，减少了创建和管理大量线程的开销。

### 语法

#### 关键词

**`async`**

- `async` 用于定义一个**协程 (Coroutine)**。协程是一种特殊的函数，它可以暂停执行，并在稍后从暂停的地方恢复。

**`await`**

- `await` 只能在 `async` 定义的函数内部使用。
- 它的作用是“暂停”当前协程的执行，并等待一个可等待对象（通常是另一个协程）完成。在等待期间，程序控制权会被释放，让事件循环可以去执行其他任务。
- 当被等待的任务完成后，`await` 表达式会返回结果，当前协程将从暂停的地方恢复执行。

#### 函数

Python 内置的异步库是 **asyncio**，常见关键点：

- **事件循环 (Event Loop)**
   所有的协程（`async def`）都会在事件循环里调度执行。

  ```
  loop = asyncio.get_running_loop()
  ```

  表示获取当前正在运行的事件循环。

- **协程 (Coroutine)**
   用 `async def` 定义，用 `await` 调用：

  ```
  async def f():
      return 1
  await f()
  ```

- **任务 (Task)**
   协程可以封装成任务在事件循环中并发运行。
   这里 FastAPI 自动帮你管理，不需要手动 `asyncio.create_task`。





##### `run_in_executor` —— 把同步任务丢进线程池

你的模型 `ActRound.run` 是 **同步阻塞函数**（可能要跑很久，比如加载模型、推理）。
 直接 `await model.run(...)` 会阻塞事件循环，所有请求都卡死。
 所以用了：

```
result, summary = await loop.run_in_executor(
    None,          # None 表示用默认的线程池（ThreadPoolExecutor）
    model.run,     # 要执行的阻塞函数
    question,      # 传入参数
    round,
    all_info
)
```

👉 **知识点**：

- `run_in_executor` 会把同步函数丢进线程池/进程池去执行。
- `await` 会挂起当前协程，直到线程池里的函数执行完成。
- 这样 FastAPI 的主事件循环仍然空闲，可以继续接收别的请求。

##### `@app.on_event("startup")`

```
@app.on_event("startup")
async def startup_event():
    ...
```

- FastAPI 提供的生命周期事件：在应用启动时会调用。
- 这里用 `loop.run_in_executor(None, ActRound)` 在后台线程里初始化模型，避免启动时卡死。















# 后端python开发

## Flask框架

### 1.@app的解释

在 Flask 中，**`@app.route` 并没有直接“创建一个网址”**，而是定义了一个 **路由规则（Route）**。它的核心作用是告诉 Flask：

> **“当用户访问某个特定的 URL 路径时，应该调用哪个函数来处理这个请求。”**

---

具体来说：

1. **它关联了一个 URL 路径和一个函数**  
   例如，`@app.route("/about")` 的作用是：  
   - 当用户访问 `http://你的网站.com/about` 时，Flask 会自动调用下方定义的视图函数（如 `about()`）。
   - 视图函数负责生成并返回响应内容（比如返回一个网页、一段文本或 JSON 数据）。

2. **URL 是“访问路径”，路由是“映射规则”**  
   - **网址（URL）** 是用户实际在浏览器中输入的地址（如 `/about`）。
   - **路由（Route）** 是 `@app.route` 定义的规则，用来将 URL 和对应的处理函数绑定在一起。

---

举个比喻：

想象一个餐厅的服务员（Flask）：
- **菜单上的菜名** 就像 **URL**（比如“宫保鸡丁”）。
- **厨师** 就像 **视图函数**（负责做这道菜）。
- **`@app.route`** 的作用就是告诉服务员：  
  “当客人点‘宫保鸡丁’时，去找王师傅（对应的函数）做这道菜。”

**`@app.route` 并没有“创造菜名”**，而是建立了“菜名”和“厨师”之间的对应关系。

### 2.基础

**网页是前端，Flask是后端，Flask接受前面的东西**

**Flask是将路由交给一个函数处理，一般来说就是@app那个。但是也可以通过一个函数去找路由**



1，2都是网址后面接的，2也是端口号

![image-20250311000913667](../AppData/Roaming/Typora/typora-user-images/image-20250311000913667.png)

访问到其他网址（不仅限于本机）

![image-20250311002613539](../AppData/Roaming/Typora/typora-user-images/image-20250311002613539.png)

### 3.DEBUG方式

如下两种和下一张图片的那种

![image-20250311191617440](../AppData/Roaming/Typora/typora-user-images/image-20250311191617440.png)

注意要在config.json里设置一个字典{"DEBUG":"True"}

![image-20250311192735508](../AppData/Roaming/Typora/typora-user-images/image-20250311192735508.png)





### 4.动态传参

这里的id是可以随便传什么就返回什么网址，这样都可以传任意参数

![image-20250311193553598](../AppData/Roaming/Typora/typora-user-images/image-20250311193553598.png)



### 5.接收到的数据类型变化

下图是规则

![image-20250311195158628](../AppData/Roaming/Typora/typora-user-images/image-20250311195158628.png)



**下图是例子，加尖括号的，尖括号前面是数据类型，中间是：号**

![image-20250311194931304](../AppData/Roaming/Typora/typora-user-images/image-20250311194931304.png)



### 6.自定义数据类型

一定要重写画圈的

![image-20250311203202027](../AppData/Roaming/Typora/typora-user-images/image-20250311203202027.png)



### 7.to_python

**该函数在反馈给我们的时候会自动执行，所以尽量在这里面写**

![image-20250311204058317](../AppData/Roaming/Typora/typora-user-images/image-20250311204058317.png)

![image-20250311204249458](../AppData/Roaming/Typora/typora-user-images/image-20250311204249458.png)





### 8.获取url路径里面的某些参数，如图

request是发给服务器那个请求

![image-20250311234826577](../AppData/Roaming/Typora/typora-user-images/image-20250311234826577.png)



![image-20250311235012227](../AppData/Roaming/Typora/typora-user-images/image-20250311235012227.png)



### 9.路径里的查询参数和请求体里的参数区别

上和下

![image-20250311235340140](../AppData/Roaming/Typora/typora-user-images/image-20250311235340140.png)



### 10.写了就是自己传的网页能用什么请求访问

![image-20250312001337784](../AppData/Roaming/Typora/typora-user-images/image-20250312001337784.png)



### 11.只有有以下属性，文件才能上传后台

![image-20250312142627752](../AppData/Roaming/Typora/typora-user-images/image-20250312142627752.png)

接收前台传的数据

![image-20250312142855438](../AppData/Roaming/Typora/typora-user-images/image-20250312142855438.png)

### 12.获取前台传的信息

![image-20250312143826711](../AppData/Roaming/Typora/typora-user-images/image-20250312143826711.png)



### 13.url_for根据函数寻找路由地址

![image-20250312150435288](../AppData/Roaming/Typora/typora-user-images/image-20250312150435288.png)



### 14.用url_for的好处

![image-20250312191406815](../AppData/Roaming/Typora/typora-user-images/image-20250312191406815.png)

技巧

![image-20250312191724420](../AppData/Roaming/Typora/typora-user-images/image-20250312191724420.png)

![image-20250312192100840](../AppData/Roaming/Typora/typora-user-images/image-20250312192100840.png)



### 15.什么叫重定向

![image-20250312192657678](../AppData/Roaming/Typora/typora-user-images/image-20250312192657678.png)

### 16.重定向函数

“code=301”是永久性重定向，302是暂时性重定向

![image-20250312193702791](../AppData/Roaming/Typora/typora-user-images/image-20250312193702791.png)



### 17.响应内容

当客户端发送一个请求到Flask服务器，服务器会响应指定内容，但Flask对这个内容有相应约束，只有如下内容才行

**1.字符串（实际是HTML代码）2.json数据 3.response**



如何创建json数据，一定要加1

![image-20250312204048364](../AppData/Roaming/Typora/typora-user-images/image-20250312204048364.png)







**以元组方式传的规则和例子**

![image-20250312202826372](../AppData/Roaming/Typora/typora-user-images/image-20250312202826372.png)

**例子**

![image-20250312203811348](../AppData/Roaming/Typora/typora-user-images/image-20250312203811348.png)

![image-20250312203413433](../AppData/Roaming/Typora/typora-user-images/image-20250312203413433.png)









## Django框架



### 1.专业术语

客户端是需要下载的

![image-20250313164741097](../AppData/Roaming/Typora/typora-user-images/image-20250313164741097.png)

MVC

![image-20250313165121660](../AppData/Roaming/Typora/typora-user-images/image-20250313165121660.png)

MTV

![image-20250313165518736](../AppData/Roaming/Typora/typora-user-images/image-20250313165518736.png)

ORM

![image-20250313172017380](../AppData/Roaming/Typora/typora-user-images/image-20250313172017380.png)

![image-20250313172333237](../AppData/Roaming/Typora/typora-user-images/image-20250313172333237.png)

## Linux系统知识

### 基础知识

#### 指令

注意rm只能删文件，不能删目录

![Screenshot_20250424_154441_tv.danmaku.bili](../Downloads/Screenshot_20250424_154441_tv.danmaku.bili.jpg)

#### command指令

![image-20250424213746682](../AppData/Roaming/Typora/typora-user-images/image-20250424213746682.png)



![image-20250424214604708](../AppData/Roaming/Typora/typora-user-images/image-20250424214604708.png)

![image-20250424215236636](../AppData/Roaming/Typora/typora-user-images/image-20250424215236636.png)













# 后端Java开发基础

## 基础

### scanner

// 问题分析：SendThread 中的 Scanner 读取失败，抛出 NoSuchElementException。
// 原因是 SendThread 与主线程共享 System.in，主线程在 main 中已经关闭了 Scanner，从而关闭了 System.in
// 之后 SendThread 中尝试读取时就会报错。
//

![image-20250716223832677](../AppData/Roaming/Typora/typora-user-images/image-20250716223832677.png)



### 注意快捷方式

#### alt+Enter

![image-20250415221739167](../AppData/Roaming/Typora/typora-user-images/image-20250415221739167.png)

![image-20250713235920040](../AppData/Roaming/Typora/typora-user-images/image-20250713235920040.png)



#### ctrl+i

自动补全实现方法



### system.in中会一直保留东西，所以可能有回车键

要这样才行

![image-20250713230630970](../AppData/Roaming/Typora/typora-user-images/image-20250713230630970.png)





### 自动补全

![image-20250713213642275](../AppData/Roaming/Typora/typora-user-images/image-20250713213642275.png)





### 数组

#### 创建方式

![image-20250421222609992](../AppData/Roaming/Typora/typora-user-images/image-20250421222609992.png)

#### 内存原理图

![image-20250421222734304](../AppData/Roaming/Typora/typora-user-images/image-20250421222734304.png)

#### 快速打出数组循环

![image-20250421223236316](../AppData/Roaming/Typora/typora-user-images/image-20250421223236316.png)



#### 排序+tostring用法

![image-20250421231940132](../AppData/Roaming/Typora/typora-user-images/image-20250421231940132.png)

#### 数组的各种方法

![image-20250424220823649](../AppData/Roaming/Typora/typora-user-images/image-20250424220823649.png)

### foreach循环

![image-20250429215656811](../AppData/Roaming/Typora/typora-user-images/image-20250429215656811.png)

### 空指针

可以打印空指针，但不能用空指针访问属性，方法等。

### 判断相等，最好用equals



### 堆栈内存资源说明

#### 栈

![image-20250503145339730](../AppData/Roaming/Typora/typora-user-images/image-20250503145339730.png)

#### 堆

注意引用数

![image-20250503150709134](../AppData/Roaming/Typora/typora-user-images/image-20250503150709134.png)

内存回收（GC）

![image-20250503151236445](../AppData/Roaming/Typora/typora-user-images/image-20250503151236445.png)



### printf的用法

![image-20250503152127538](../AppData/Roaming/Typora/typora-user-images/image-20250503152127538.png)

### 如何建包

![image-20250503160159282](../AppData/Roaming/Typora/typora-user-images/image-20250503160159282.png)

可以用这些建包

![image-20250503160309770](../AppData/Roaming/Typora/typora-user-images/image-20250503160309770.png)

### 如何定义常量

必须要在类里面定义

![image-20250504114013581](../AppData/Roaming/Typora/typora-user-images/image-20250504114013581.png)

**如何访问**

![image-20250504114119553](../AppData/Roaming/Typora/typora-user-images/image-20250504114119553.png)

### Java最小组织单元

![image-20250504114215907](../AppData/Roaming/Typora/typora-user-images/image-20250504114215907.png)



### static

#### 静态属性

**后创建的可以访问先创建的，静态区创建比较靠前，堆区在后面**

![image-20250504115941273](../AppData/Roaming/Typora/typora-user-images/image-20250504115941273.png)

#### 静态代码块

**红色是执行顺序**

![image-20250504151314168](../AppData/Roaming/Typora/typora-user-images/image-20250504151314168.png)

### 需要关注的

##### 1.

返回的需要json格式，可以直接把对象或集合返回

### 泛型

#### 简介

![image-20250811001101718](../AppData/Roaming/Typora/typora-user-images/image-20250811001101718.png)

#### 未加泛型

![image-20250811001418532](../AppData/Roaming/Typora/typora-user-images/image-20250811001418532.png)

#### 加入泛型

![image-20250811001552012](../AppData/Roaming/Typora/typora-user-images/image-20250811001552012.png)









## 函数

### 函数重载

**参数列表不相同是他那个数据类型和数量不同**

![image-20250429212304482](../AppData/Roaming/Typora/typora-user-images/image-20250429212304482.png)

### 如何传递任意多个参数

![image-20250429212955818](../AppData/Roaming/Typora/typora-user-images/image-20250429212955818.png)



### 地址传递方法及原理

![image-20250501092641770](../AppData/Roaming/Typora/typora-user-images/image-20250501092641770.png)



### 值传递方法及原理

![image-20250501092834885](../AppData/Roaming/Typora/typora-user-images/image-20250501092834885.png)

















## 各种类型及转换

![image-20250415222106897](../AppData/Roaming/Typora/typora-user-images/image-20250415222106897.png)



转换

![image-20250416202230654](../AppData/Roaming/Typora/typora-user-images/image-20250416202230654.png)

![image-20250416202336141](../AppData/Roaming/Typora/typora-user-images/image-20250416202336141.png)



几种数据类型

![image-20250416202848626](../AppData/Roaming/Typora/typora-user-images/image-20250416202848626.png)



double 非常长

![image-20250416203252730](../AppData/Roaming/Typora/typora-user-images/image-20250416203252730.png)



![image-20250416204013415](../AppData/Roaming/Typora/typora-user-images/image-20250416204013415.png)



### 引用数据类型是除基本数据类型以外的

引用数据类型就是里面记录了一个地址（这是本质）

堆不需要人工赋值都能读，0；但是栈不行





## 面向对象

### 基础

#### 命名

**一个文件只有一个类与文件名一样，且文件内只有一个public类，否则报错**

#### 入门示例

![image-20250501102218281](../AppData/Roaming/Typora/typora-user-images/image-20250501102218281.png)

![image-20250501102141848](../AppData/Roaming/Typora/typora-user-images/image-20250501102141848.png)

#### 类的内存图

![image-20250502210521436](../AppData/Roaming/Typora/typora-user-images/image-20250502210521436.png)

#### 多个对象内存图

![image-20250502220249336](../AppData/Roaming/Typora/typora-user-images/image-20250502220249336.png)

#### 注意这里的文件放置

![image-20250503220832094](../AppData/Roaming/Typora/typora-user-images/image-20250503220832094.png)

#### 满参传递

![image-20250503222114782](../AppData/Roaming/Typora/typora-user-images/image-20250503222114782.png)

### 内部类

![image-20250716172642899](../AppData/Roaming/Typora/typora-user-images/image-20250716172642899.png)



#### 成员内部类

![image-20250716180006787](../AppData/Roaming/Typora/typora-user-images/image-20250716180006787.png)

![image-20250716180511329](../AppData/Roaming/Typora/typora-user-images/image-20250716180511329.png)

#### 静态内部类

![image-20250716184826151](../AppData/Roaming/Typora/typora-user-images/image-20250716184826151.png)

![image-20250716180055590](../AppData/Roaming/Typora/typora-user-images/image-20250716180055590.png)





#### 局部内部类

![image-20250716174818168](../AppData/Roaming/Typora/typora-user-images/image-20250716174818168.png)

#### 匿名类

![image-20250716175218179](../AppData/Roaming/Typora/typora-user-images/image-20250716175218179.png)

new Thread的子类

![image-20250716175603197](../AppData/Roaming/Typora/typora-user-images/image-20250716175603197.png)



### 类属性自动初始化

**在Java中，类的属性会自动初始化，但局部变量不会**



### 面向对象三大特性

#### 封装

##### **为什么需要封装**

![image-20250503224332105](../AppData/Roaming/Typora/typora-user-images/image-20250503224332105.png)

##### 步骤

![image-20250503224457880](../AppData/Roaming/Typora/typora-user-images/image-20250503224457880.png)

#### this 指针

**注意图上的要点**

![image-20250504001937580](../AppData/Roaming/Typora/typora-user-images/image-20250504001937580.png)

###### **注意**



![image-20250504152928008](../AppData/Roaming/Typora/typora-user-images/image-20250504152928008.png)

##### 这里既可用super，也可用this

这里的父类是私有

![image-20250509161802048](../AppData/Roaming/Typora/typora-user-images/image-20250509161802048.png)



#### 继承

##### 写在前面的事（特别注意第一张图）

![image-20250509164430585](../AppData/Roaming/Typora/typora-user-images/image-20250509164430585.png)

![image-20250504152845590](../AppData/Roaming/Typora/typora-user-images/image-20250504152845590.png)

##### super关键字

**super必须写在第一行**

![image-20250504155746729](../AppData/Roaming/Typora/typora-user-images/image-20250504155746729.png)

![image-20250504155721338](../AppData/Roaming/Typora/typora-user-images/image-20250504155721338.png)

##### 四大基本权限

**注意这边的包**

![image-20250504161248750](../AppData/Roaming/Typora/typora-user-images/image-20250504161248750.png)

![image-20250504161212230](../AppData/Roaming/Typora/typora-user-images/image-20250504161212230.png)

##### 重写

![image-20250505223401840](../AppData/Roaming/Typora/typora-user-images/image-20250505223401840.png)

方法重写规则

![image-20250508102219696](../AppData/Roaming/Typora/typora-user-images/image-20250508102219696.png)

##### Object的几个基本继承方法

##### 总的

![image-20250508102559790](../AppData/Roaming/Typora/typora-user-images/image-20250508102559790.png)

##### toString重写

![image-20250508105335185](../AppData/Roaming/Typora/typora-user-images/image-20250508105335185.png)

##### equals方法

![image-20250508110043287](../AppData/Roaming/Typora/typora-user-images/image-20250508110043287.png)



##### hashCode方法

![image-20250508110335807](../AppData/Roaming/Typora/typora-user-images/image-20250508110335807.png)

##### getClass方法及类的底层

![image-20250508111244377](../AppData/Roaming/Typora/typora-user-images/image-20250508111244377.png)

##### 抽象类

###### 怎么写

作用：不能new。方法：

![image-20250508114356453](../AppData/Roaming/Typora/typora-user-images/image-20250508114356453.png)

###### 抽象方法

子类是抽象类，可以不重写该方法

抽象方法的父类没有方法体

![image-20250508142324715](../AppData/Roaming/Typora/typora-user-images/image-20250508142324715.png)

##### 最终类

![image-20250508143018076](../AppData/Roaming/Typora/typora-user-images/image-20250508143018076.png)

#### 多态

##### 大的不能送给小的，小的能送给大的（指的是数据类型）

##### 解释

大变小

![image-20250509101900461](../AppData/Roaming/Typora/typora-user-images/image-20250509101900461.png)

##### 多态实现思路

![image-20250509105210655](../AppData/Roaming/Typora/typora-user-images/image-20250509105210655.png)

###### 多态第一种实现（最常用）

![image-20250509111056982](../AppData/Roaming/Typora/typora-user-images/image-20250509111056982.png)

![image-20250509111209209](../AppData/Roaming/Typora/typora-user-images/image-20250509111209209.png)

![image-20250509111335436](../AppData/Roaming/Typora/typora-user-images/image-20250509111335436.png)

###### 第二种多态（不常用）

####### 解释

![image-20250509123505682](../AppData/Roaming/Typora/typora-user-images/image-20250509123505682.png)

![image-20250509123401460](../AppData/Roaming/Typora/typora-user-images/image-20250509123401460.png)

###### 例子

![image-20250509124919641](../AppData/Roaming/Typora/typora-user-images/image-20250509124919641.png)

![image-20250509124843959](../AppData/Roaming/Typora/typora-user-images/image-20250509124843959.png)

##### 父类到子类的转换

###### 转换方式

![image-20250509130841393](../AppData/Roaming/Typora/typora-user-images/image-20250509130841393.png)

![image-20250509131134840](../AppData/Roaming/Typora/typora-user-images/image-20250509131134840.png)

**子类独有方法**

![image-20250509131333083](../AppData/Roaming/Typora/typora-user-images/image-20250509131333083.png)

### 接口

#### 接口的由来

![image-20250509195033958](../AppData/Roaming/Typora/typora-user-images/image-20250509195033958.png)

#### 深入理解interface和extends

“是”用类，“具有”用extends

![image-20250509195908561](../AppData/Roaming/Typora/typora-user-images/image-20250509195908561.png)

#### 多接口

![image-20250509202628975](../AppData/Roaming/Typora/typora-user-images/image-20250509202628975.png)

#### 接口属性和方法特点

![image-20250509203119913](../AppData/Roaming/Typora/typora-user-images/image-20250509203119913.png)

### 异常机制处理

#### 语法



![image-20250814211138659](../AppData/Roaming/Typora/typora-user-images/image-20250814211138659.png)

##### `throw` 关键字



`throw` 的作用是**主动抛出**一个异常对象。它用于在程序中显式地创建一个异常实例，并立即停止当前方法的执行，将控制权交给异常处理机制。

**语法：**

Java

```
throw new ExceptionType("错误信息");
```

**特点：**

- **`throw` 后面跟的是一个具体的异常对象实例**，例如 `new IllegalArgumentException("年龄不能为负数")`。
- 它**立即终止**当前方法的执行，后面的代码将不再被执行。
- 它通常用于以下场景：
  - **业务逻辑校验**：当你的方法参数不符合要求，或者业务状态不正确时，可以抛出异常来中断流程。例如，`setAge(int age)` 方法中，如果 `age` 小于 0，就可以 `throw new IllegalArgumentException()`。
  - **封装底层异常**：在 `catch` 块中捕获一个低级别的异常，然后将其封装成一个更符合业务含义的高级别异常再重新抛出。这通常被称为“异常链”（Exception Chaining）。



##### `throws` 关键字



`throws` 的作用是**声明**一个方法可能会抛出哪些异常。它不是用来真正抛出异常的，而是用来**告诉调用者**，这个方法在执行过程中可能会出现这些异常，所以调用者需要处理它们。

**语法：**

Java

```
public void methodName() throws ExceptionType1, ExceptionType2 {
    // 方法体
}
```

**特点：**

- **`throws` 后面跟的是异常类型（Class）**，而不是异常对象实例。
- 它用于**方法签名**中，在参数列表的后面。
- 它主要用于处理**受检异常**（Checked Exception）。Java 强制要求，如果一个方法可能会抛出受检异常，那么它必须在方法签名上使用 `throws` 关键字进行声明，否则编译不通过。
- 当一个方法被 `throws` 声明了异常后，调用这个方法的代码要么使用 `try-catch` 块来处理这个异常，要么也继续在自己的方法签名上使用 `throws` 声明这个异常，将其“向上抛”。





![image-20250814212644343](../AppData/Roaming/Typora/typora-user-images/image-20250814212644343.png)

![image-20250511104831594](../AppData/Roaming/Typora/typora-user-images/image-20250511104831594.png)

#### 打印异常信息

![image-20250511105705109](../AppData/Roaming/Typora/typora-user-images/image-20250511105705109.png)

#### finally

**finally 很强大，哪怕是这里的return 也挡不住他的执行，唯一能挡住他的执行是exit，它会直接中断虚拟机**

![image-20250511110430750](../AppData/Roaming/Typora/typora-user-images/image-20250511110430750.png)

#### 异常catch顺序

![image-20250511111117838](../AppData/Roaming/Typora/typora-user-images/image-20250511111117838.png)

#### throw和throws

用法

![image-20250511111652074](../AppData/Roaming/Typora/typora-user-images/image-20250511111652074.png)

**注意**

**f02这里是抛出异常，一定要接收掉程序才能正常运行（用try接收）**

![image-20250511112429794](../AppData/Roaming/Typora/typora-user-images/image-20250511112429794.png)

#### 异常的继承关系

![image-20250511114231034](../AppData/Roaming/Typora/typora-user-images/image-20250511114231034.png)

#### 自定义异常

第一种

![image-20250511114734231](../AppData/Roaming/Typora/typora-user-images/image-20250511114734231.png)

![image-20250511114709736](../AppData/Roaming/Typora/typora-user-images/image-20250511114709736.png)

第二种

![image-20250511114955392](../AppData/Roaming/Typora/typora-user-images/image-20250511114955392.png)

![image-20250511114917440](../AppData/Roaming/Typora/typora-user-images/image-20250511114917440.png)

### jar包

#### 步骤

##### 1.将什么打包

![image-20250512112027009](../AppData/Roaming/Typora/typora-user-images/image-20250512112027009.png)

##### 2.找到文件，并压缩成.zip

![image-20250512112238523](../AppData/Roaming/Typora/typora-user-images/image-20250512112238523.png)

##### 3.更改后缀

![image-20250512112341958](../AppData/Roaming/Typora/typora-user-images/image-20250512112341958.png)

##### 4.创建一个路径

![image-20250512112554712](../AppData/Roaming/Typora/typora-user-images/image-20250512112554712.png)

##### 5.把jar包放进去

##### 6.还不能用

![image-20250512112908705](../AppData/Roaming/Typora/typora-user-images/image-20250512112908705.png)

![image-20250512112941667](../AppData/Roaming/Typora/typora-user-images/image-20250512112941667.png)

##### 7.找到源文件

![image-20250512113151163](../AppData/Roaming/Typora/typora-user-images/image-20250512113151163.png)

![image-20250512113238778](../AppData/Roaming/Typora/typora-user-images/image-20250512113238778.png)

##### 8.一般不把它放在lib里，一般放在

![image-20250512113419931](../AppData/Roaming/Typora/typora-user-images/image-20250512113419931.png)

##### 9.选择这个

![image-20250512113558967](../AppData/Roaming/Typora/typora-user-images/image-20250512113558967.png)

##### 10.最终

![image-20250512113940498](../AppData/Roaming/Typora/typora-user-images/image-20250512113940498.png)



## 客户端与服务端通信

### 示例

![image-20250514210051428](../AppData/Roaming/Typora/typora-user-images/image-20250514210051428.png)

客户端

![image-20250514210136145](../AppData/Roaming/Typora/typora-user-images/image-20250514210136145.png)

服务端

![image-20250514210258968](../AppData/Roaming/Typora/typora-user-images/image-20250514210258968.png)

## 软件开发须知

### 软件开发流程

![image-20250515234847511](../AppData/Roaming/Typora/typora-user-images/image-20250515234847511.png)

### 常用设计原则

#### 1.开闭原则

就是测试后的代码，尽量不要修改（某些情况可以转换继承）

![image-20250516000327081](../AppData/Roaming/Typora/typora-user-images/image-20250516000327081.png)

#### 2.里氏代换原则

![image-20250516000730851](../AppData/Roaming/Typora/typora-user-images/image-20250516000730851.png)

#### 3.依赖倒转原则

![image-20250516002212113](../AppData/Roaming/Typora/typora-user-images/image-20250516002212113.png)

#### 4.接口隔离原则

![image-20250516002644619](../AppData/Roaming/Typora/typora-user-images/image-20250516002644619.png)

#### 5.最少知道原则

![image-20250516112835760](../AppData/Roaming/Typora/typora-user-images/image-20250516112835760.png)

#### 6.合成复用原则

继承不好是因为Java只能单继承，并且继承的方法可能很多

![image-20250516113215130](../AppData/Roaming/Typora/typora-user-images/image-20250516113215130.png)

### 设计模式

#### 1.基本概念

![image-20250516113741332](../AppData/Roaming/Typora/typora-user-images/image-20250516113741332.png)

#### 设计模式分类

![image-20250516130057838](../AppData/Roaming/Typora/typora-user-images/image-20250516130057838.png)

##### 单例设计模式

###### 概念

![image-20250516131718883](../AppData/Roaming/Typora/typora-user-images/image-20250516131718883.png)

###### 分类

![image-20250516132215640](../AppData/Roaming/Typora/typora-user-images/image-20250516132215640.png)

###### 创建方法--饿汉式

**饿汉式方式一**

这是第一个类

**之所以用static，是因为外部无法创建类，就无法访问方法，所以就加入static，用类名访问**

![image-20250516132801651](../AppData/Roaming/Typora/typora-user-images/image-20250516132801651.png)

这是第二个类

![image-20250516133752780](../AppData/Roaming/Typora/typora-user-images/image-20250516133752780.png)

**饿汉式方式二**

**静态代码块**

![image-20250516134449211](../AppData/Roaming/Typora/typora-user-images/image-20250516134449211.png)



![image-20250516134601174](../AppData/Roaming/Typora/typora-user-images/image-20250516134601174.png)

**最后的说明**

![image-20250516134703926](../AppData/Roaming/Typora/typora-user-images/image-20250516134703926.png)

###### 创建方法--懒汉式

**方法一**

**注意这里要加个锁，这样多线程才安全**

![image-20250516222958361](../AppData/Roaming/Typora/typora-user-images/image-20250516222958361.png)

方法二

**为什么要加一些东西的原因**

![image-20250516223725873](../AppData/Roaming/Typora/typora-user-images/image-20250516223725873.png)

![image-20250516223638543](../AppData/Roaming/Typora/typora-user-images/image-20250516223638543.png)

实现

![image-20250516223606288](../AppData/Roaming/Typora/typora-user-images/image-20250516223606288.png)

方法三

**创建原理和创建方法**

![image-20250516225225979](../AppData/Roaming/Typora/typora-user-images/image-20250516225225979.png)

优点

![image-20250516225501573](../AppData/Roaming/Typora/typora-user-images/image-20250516225501573.png)

###### 创建方法--饿汉式最简

![image-20250516225814168](../AppData/Roaming/Typora/typora-user-images/image-20250516225814168.png)

![image-20250517124642899](../AppData/Roaming/Typora/typora-user-images/image-20250517124642899.png)



##### 单例模式存在的问题

![image-20250517125946975](../AppData/Roaming/Typora/typora-user-images/image-20250517125946975.png)

###### 序列化破坏单例模式

**写入**

![image-20250517125232343](../AppData/Roaming/Typora/typora-user-images/image-20250517125232343.png)

**读入**

![image-20250517125540336](../AppData/Roaming/Typora/typora-user-images/image-20250517125540336.png)

###### 反射破坏单例模式

![image-20250517130414975](../AppData/Roaming/Typora/typora-user-images/image-20250517130414975.png)

###### 以上第一种问题的解决

![image-20250518000101184](../AppData/Roaming/Typora/typora-user-images/image-20250518000101184.png)

![image-20250518000707664](../AppData/Roaming/Typora/typora-user-images/image-20250518000707664.png)

###### 第二种问题的解决

![image-20250518001306499](../AppData/Roaming/Typora/typora-user-images/image-20250518001306499.png)



## 核心编程

### 常用API

#### 基本数据类型包装类

![image-20250519103102632](../AppData/Roaming/Typora/typora-user-images/image-20250519103102632.png)

![image-20250519102509425](../AppData/Roaming/Typora/typora-user-images/image-20250519102509425.png)

![image-20250519102726359](../AppData/Roaming/Typora/typora-user-images/image-20250519102726359.png)

![image-20250519102859893](../AppData/Roaming/Typora/typora-user-images/image-20250519102859893.png)

#### Java中的时间

![image-20250519110343701](../AppData/Roaming/Typora/typora-user-images/image-20250519110343701.png)

**Date最擅长拿到时间和做时间差**

![image-20250519110232153](../AppData/Roaming/Typora/typora-user-images/image-20250519110232153.png)



**下面是Calendar用法**

![image-20250519110049608](../AppData/Roaming/Typora/typora-user-images/image-20250519110049608.png)

![image-20250519105935685](../AppData/Roaming/Typora/typora-user-images/image-20250519105935685.png)

#### 格式化时间

![image-20250519111111859](../AppData/Roaming/Typora/typora-user-images/image-20250519111111859.png)

![image-20250519111453978](../AppData/Roaming/Typora/typora-user-images/image-20250519111453978.png)

![image-20250519111317123](../AppData/Roaming/Typora/typora-user-images/image-20250519111317123.png)

#### String类

**字符串是不可变的数据类型，改变字符串的操作都是返回一个新的字符串**

![image-20250519233328606](../AppData/Roaming/Typora/typora-user-images/image-20250519233328606.png)

![image-20250519233852260](../AppData/Roaming/Typora/typora-user-images/image-20250519233852260.png)

![image-20250519234204853](../AppData/Roaming/Typora/typora-user-images/image-20250519234204853.png)

#### StringBuilder和StringBuffer

比String的优势是自身可变

![image-20250520000616701](../AppData/Roaming/Typora/typora-user-images/image-20250520000616701.png)

![image-20250520000517992](../AppData/Roaming/Typora/typora-user-images/image-20250520000517992.png)

### IO流

#### 简介

![image-20250520001408516](../AppData/Roaming/Typora/typora-user-images/image-20250520001408516.png)

#### 文件操作File类

**1是拿文件对象，二是拿文件名**

![image-20250520162111106](../AppData/Roaming/Typora/typora-user-images/image-20250520162111106.png)

**相对路径创建文件一定要先创建文件夹，如下图**

![image-20250520162607956](../AppData/Roaming/Typora/typora-user-images/image-20250520162607956.png)

#### 节点流

##### 分类

注意这句话

![image-20250520172728426](../AppData/Roaming/Typora/typora-user-images/image-20250520172728426.png)

文件流是子类

![image-20250520172602684](../AppData/Roaming/Typora/typora-user-images/image-20250520172602684.png

![](../AppData/Roaming/Typora/typora-user-images/image-20250520172544413.png)

##### 详细解释

![image-20250520172049495](../AppData/Roaming/Typora/typora-user-images/image-20250520172049495.png)

**字节流不能读中文，只能读一半**

##### 字节流

FileInputStream读方法

![image-20250520174000973](../AppData/Roaming/Typora/typora-user-images/image-20250520174000973.png)

FileOutputStream写方法

![image-20250520174510243](../AppData/Roaming/Typora/typora-user-images/image-20250520174510243.png)

##### 字符流

![image-20250520174732969](../AppData/Roaming/Typora/typora-user-images/image-20250520174732969.png)

![image-20250520174813686](../AppData/Roaming/Typora/typora-user-images/image-20250520174813686.png)

##### 如何选择

**读视频选字节流，读文字选字符流**

![image-20250520174919421](../AppData/Roaming/Typora/typora-user-images/image-20250520174919421.png)

#### 处理流

##### 介绍

![image-20250521150931308](../AppData/Roaming/Typora/typora-user-images/image-20250521150931308.png)

##### 缓冲流

要套在节点上，如图

![image-20250521151115539](../AppData/Roaming/Typora/typora-user-images/image-20250521151115539.png)

**Bufferedreader很方便，建议使用（读取的是字符流）**，其他的Buffered跟FIle开头的一模一样建议不使用

![image-20250521151446058](../AppData/Roaming/Typora/typora-user-images/image-20250521151446058.png)

##### 转换流

这里是字节流先转换成字符流（IputStreamReader），再加上缓冲区

![image-20250521154511405](../AppData/Roaming/Typora/typora-user-images/image-20250521154511405.png)

这里也是先转换成字符流

![image-20250521154354485](../AppData/Roaming/Typora/typora-user-images/image-20250521154354485.png)

##### 对象流

是什么：

![image-20250521155648892](../AppData/Roaming/Typora/typora-user-images/image-20250521155648892.png)

写

![image-20250521155822539](../AppData/Roaming/Typora/typora-user-images/image-20250521155822539.png)



读

![image-20250521155737108](../AppData/Roaming/Typora/typora-user-images/image-20250521155737108.png)



#### 文件修改

**思路**

![image-20250522144126135](../AppData/Roaming/Typora/typora-user-images/image-20250522144126135.png)

代码

![image-20250522144559949](../AppData/Roaming/Typora/typora-user-images/image-20250522144559949.png)



### 多线程

#### 多线程感悟

其实可以简单理解，如果在一个主函数内开了多个start，就相当于这几个start同时进行

#### 操作系统简介

![image-20250522150438947](../AppData/Roaming/Typora/typora-user-images/image-20250522150438947.png)

#### 什么是进程，什么是线程

![image-20250522152552427](../AppData/Roaming/Typora/typora-user-images/image-20250522152552427.png)

#### 实现的两种方法

![image-20250522160338951](../AppData/Roaming/Typora/typora-user-images/image-20250522160338951.png)

##### 方法一



![image-20250522160308938](../AppData/Roaming/Typora/typora-user-images/image-20250522160308938.png)

![image-20250522160233831](../AppData/Roaming/Typora/typora-user-images/image-20250522160233831.png)

##### 方法二



![image-20250522160513808](../AppData/Roaming/Typora/typora-user-images/image-20250522160513808.png)

![image-20250522160434837](../AppData/Roaming/Typora/typora-user-images/image-20250522160434837.png)

#### 线程相关操作

##### 线程中相关方法

![image-20250523102949670](../AppData/Roaming/Typora/typora-user-images/image-20250523102949670.png)

##### 设置优先级

![image-20250523103902762](../AppData/Roaming/Typora/typora-user-images/image-20250523103902762.png)

##### sleep方法

![image-20250523104045034](../AppData/Roaming/Typora/typora-user-images/image-20250523104045034.png)



##### join方法

![image-20250523102111529](../AppData/Roaming/Typora/typora-user-images/image-20250523102111529.png)

##### yield

**放弃了不一定意味着后跑**

![image-20250523104351476](../AppData/Roaming/Typora/typora-user-images/image-20250523104351476.png)

##### interrupt



![image-20250523104644582](../AppData/Roaming/Typora/typora-user-images/image-20250523104644582.png)

![image-20250523104601874](../AppData/Roaming/Typora/typora-user-images/image-20250523104601874.png)

#### 线程同步



##### 方法简介

![image-20250523154209382](../AppData/Roaming/Typora/typora-user-images/image-20250523154209382.png)

##### 第一种方法

![image-20250523154426097](../AppData/Roaming/Typora/typora-user-images/image-20250523154426097.png)



##### 第二种方法最推荐（他最灵活）

![image-20250523155754147](../AppData/Roaming/Typora/typora-user-images/image-20250523155754147.png)

![image-20250523155715963](../AppData/Roaming/Typora/typora-user-images/image-20250523155715963.png)

![image-20250523154331702](../AppData/Roaming/Typora/typora-user-images/image-20250523154331702.png)

#### 死锁

![image-20250523162321067](../AppData/Roaming/Typora/typora-user-images/image-20250523162321067.png)

##### 示范

![image-20250523160636976](../AppData/Roaming/Typora/typora-user-images/image-20250523160636976.png)

![image-20250523162428091](../AppData/Roaming/Typora/typora-user-images/image-20250523162428091.png)

#### 线程的生命周期

![image-20250523163023898](../AppData/Roaming/Typora/typora-user-images/image-20250523163023898.png)

#### 生产者消费者模型

![image-20250523224808084](../AppData/Roaming/Typora/typora-user-images/image-20250523224808084.png)

主函数

![image-20250523224854833](../AppData/Roaming/Typora/typora-user-images/image-20250523224854833.png)

![image-20250523235940913](../AppData/Roaming/Typora/typora-user-images/image-20250523235940913.png)

![image-20250523225101969](../AppData/Roaming/Typora/typora-user-images/image-20250523225101969.png)

![image-20250523225148113](../AppData/Roaming/Typora/typora-user-images/image-20250523225148113.png)



## 网络编程

### 网络简介

![image-20250525211127419](../AppData/Roaming/Typora/typora-user-images/image-20250525211127419.png)

互联网协议



![image-20250525210848070](../AppData/Roaming/Typora/typora-user-images/image-20250525210848070.png)

物理层

![image-20250525211202733](../AppData/Roaming/Typora/typora-user-images/image-20250525211202733.png)

数据链路层

![image-20250525211325801](../AppData/Roaming/Typora/typora-user-images/image-20250525211325801.png)

![image-20250525211644986](../AppData/Roaming/Typora/typora-user-images/image-20250525211644986.png)

网络层

内部发消息，有子网掩码

![image-20250525212237369](../AppData/Roaming/Typora/typora-user-images/image-20250525212237369.png)

![image-20250525220002159](../AppData/Roaming/Typora/typora-user-images/image-20250525220002159.png)

传输层

![image-20250525220942955](../AppData/Roaming/Typora/typora-user-images/image-20250525220942955.png)





TCP

![image-20250525220642701](../AppData/Roaming/Typora/typora-user-images/image-20250525220642701.png)

UDP

![image-20250525220806970](../AppData/Roaming/Typora/typora-user-images/image-20250525220806970.png)

ARP就是获取对方MAC的协议

这里的IP头是对方的IP头

![image-20250525221949105](../AppData/Roaming/Typora/typora-user-images/image-20250525221949105.png)

知识点

![image-20250525222518389](../AppData/Roaming/Typora/typora-user-images/image-20250525222518389.png)

### ServerSocket和Socket

![image-20250714214506571](../AppData/Roaming/Typora/typora-user-images/image-20250714214506571.png)

![image-20250714214527155](../AppData/Roaming/Typora/typora-user-images/image-20250714214527155.png)





### TCP编程

#### 写在前面的介绍

![image-20250526105020810](../AppData/Roaming/Typora/typora-user-images/image-20250526105020810.png)



#### IP地址与端口号区别

![image-20250713143903910](../AppData/Roaming/Typora/typora-user-images/image-20250713143903910.png)

![image-20250713144026700](../AppData/Roaming/Typora/typora-user-images/image-20250713144026700.png)

![image-20250713144059703](../AppData/Roaming/Typora/typora-user-images/image-20250713144059703.png)

#### 类比

![image-20250713141927813](../AppData/Roaming/Typora/typora-user-images/image-20250713141927813.png)







#### socket编程

![image-20250526105454377](../AppData/Roaming/Typora/typora-user-images/image-20250526105454377.png)

![image-20250526105558024](../AppData/Roaming/Typora/typora-user-images/image-20250526105558024.png)

![image-20250526105612506](../AppData/Roaming/Typora/typora-user-images/image-20250526105612506.png)

#### socket的数据传送

![image-20250526115850098](../AppData/Roaming/Typora/typora-user-images/image-20250526115850098.png)

![image-20250526120324485](../AppData/Roaming/Typora/typora-user-images/image-20250526120324485.png)

![image-20250526120400162](../AppData/Roaming/Typora/typora-user-images/image-20250526120400162.png)

#### 多线程解决聊天问题

![image-20250527121614797](../AppData/Roaming/Typora/typora-user-images/image-20250527121614797.png)

![image-20250527121650403](../AppData/Roaming/Typora/typora-user-images/image-20250527121650403.png)

接收数据

![image-20250527121837326](../AppData/Roaming/Typora/typora-user-images/image-20250527121837326.png)

发送数据

![image-20250713135527505](../AppData/Roaming/Typora/typora-user-images/image-20250713135527505.png)

### UDP编程

#### 基础语法

ds端口号

![image-20250716190602580](../AppData/Roaming/Typora/typora-user-images/image-20250716190602580.png)

dp都是对方

![image-20250716192537447](../AppData/Roaming/Typora/typora-user-images/image-20250716192537447.png)



#### 基本流程

![image-20250713220214430](../AppData/Roaming/Typora/typora-user-images/image-20250713220214430.png)

![image-20250713220345754](../AppData/Roaming/Typora/typora-user-images/image-20250713220345754.png)

#### 多人聊天室

![image-20250714120322884](../AppData/Roaming/Typora/typora-user-images/image-20250714120322884.png)

![image-20250714120518747](../AppData/Roaming/Typora/typora-user-images/image-20250714120518747.png)

![image-20250714120900836](../AppData/Roaming/Typora/typora-user-images/image-20250714120900836.png)

![image-20250714123049852](../AppData/Roaming/Typora/typora-user-images/image-20250714123049852.png)

两个线程

![image-20250714123319045](../AppData/Roaming/Typora/typora-user-images/image-20250714123319045.png)

![image-20250714123344347](../AppData/Roaming/Typora/typora-user-images/image-20250714123344347.png)



#### 语法讲解

// 1. 创建缓冲区（1024字节空数组）
byte[] bytes = new byte[1024]; 

// 2. 创建数据包容器，关联缓冲区
DatagramPacket dp = new DatagramPacket(bytes, 1024); 

// 3. 关键操作：阻塞接收数据（线程暂停直到数据到达）
ds.receive(dp);  // 数据会被填充到 bytes 数组中

![image-20250714121215704](../AppData/Roaming/Typora/typora-user-images/image-20250714121215704.png)

# Java后端开发Web

## 后续

![image-20250828175656800](../AppData/Roaming/Typora/typora-user-images/image-20250828175656800.png)

## 基础

#### http协议

![image-20250717173110283](../AppData/Roaming/Typora/typora-user-images/image-20250717173110283.png)



#### http请求响应步骤

![image-20250717173417118](../AppData/Roaming/Typora/typora-user-images/image-20250717173417118.png)

![image-20250717173549501](../AppData/Roaming/Typora/typora-user-images/image-20250717173549501.png)

![image-20250717222910878](../AppData/Roaming/Typora/typora-user-images/image-20250717222910878.png)

#### http请求方法

![image-20250717223328634](../AppData/Roaming/Typora/typora-user-images/image-20250717223328634.png)

#### 两种开发模型B/S和C/S优缺点

![image-20250717223516156](../AppData/Roaming/Typora/typora-user-images/image-20250717223516156.png)

![image-20250717223734799](../AppData/Roaming/Typora/typora-user-images/image-20250717223734799.png)

#### Web服务器

![image-20250717230649886](../AppData/Roaming/Typora/typora-user-images/image-20250717230649886.png)



### Servlet

#### 什么是Servlet

![image-20250718220906441](../AppData/Roaming/Typora/typora-user-images/image-20250718220906441.png)

#### Servlet API

![image-20250718221037378](../AppData/Roaming/Typora/typora-user-images/image-20250718221037378.png)

#### Servlet逻辑

![image-20250719003430984](../AppData/Roaming/Typora/typora-user-images/image-20250719003430984.png)

#### Servlet工作原理

注意这个是单例模式

![image-20250719175112257](../AppData/Roaming/Typora/typora-user-images/image-20250719175112257.png)

#### Servlet生存周期

![image-20250719183111935](../AppData/Roaming/Typora/typora-user-images/image-20250719183111935.png)

#### 请求

![image-20250719204516339](../AppData/Roaming/Typora/typora-user-images/image-20250719204516339.png)

#### get与post

##### 客户端如何发送信息给服务端

![image-20250719230841390](../AppData/Roaming/Typora/typora-user-images/image-20250719230841390.png)

##### 处理乱码

![image-20250719231002963](../AppData/Roaming/Typora/typora-user-images/image-20250719231002963.png)

##### get/post的区别

![image-20250719231946356](../AppData/Roaming/Typora/typora-user-images/image-20250719231946356.png)

#### 响应

![image-20250719233640973](../AppData/Roaming/Typora/typora-user-images/image-20250719233640973.png)

**重定向与转发区别**

![image-20250719234339547](../AppData/Roaming/Typora/typora-user-images/image-20250719234339547.png)

**区别**

![image-20250719234509238](../AppData/Roaming/Typora/typora-user-images/image-20250719234509238.png)



![image-20250719234009813](../AppData/Roaming/Typora/typora-user-images/image-20250719234009813.png)

#### session会话

![image-20250720170828311](../AppData/Roaming/Typora/typora-user-images/image-20250720170828311.png)

![image-20250720171241992](../AppData/Roaming/Typora/typora-user-images/image-20250720171241992.png)

#### 初始化参数设置



![image-20250720172321999](../AppData/Roaming/Typora/typora-user-images/image-20250720172321999.png)

![image-20250720172537477](../AppData/Roaming/Typora/typora-user-images/image-20250720172537477.png)

#### servlet3.0注解实现

##### 资料

![image-20250720172638706](../AppData/Roaming/Typora/typora-user-images/image-20250720172638706.png)

![image-20250720174336949](../AppData/Roaming/Typora/typora-user-images/image-20250720174336949.png)

![image-20250720180824025](../AppData/Roaming/Typora/typora-user-images/image-20250720180824025.png)

![image-20250720205744522](../AppData/Roaming/Typora/typora-user-images/image-20250720205744522.png)

注解

![image-20250720215020943](../AppData/Roaming/Typora/typora-user-images/image-20250720215020943.png)

![image-20250720215104633](../AppData/Roaming/Typora/typora-user-images/image-20250720215104633.png)

在 Java Servlet 中，`doGet()` 和 `doPost()` 是两个核心方法，用于处理不同类型的 HTTP 请求。它们共同构成了 Servlet 处理客户端请求的基础：

##### 1. `doGet()` 方法

java

```
@Override
protected void doGet(HttpServletRequest req, HttpServletResponse resp) {
    // 处理 GET 请求的逻辑
}
```

- **作用**：专门处理 HTTP **GET** 请求
- **典型场景**：
  - 浏览器地址栏直接输入 URL
  - 点击网页链接 (`<a href="...">`)
  - 表单提交指定 `method="GET"`
  - 网页加载图片/CSS/JS 等静态资源
- **特点**：
  - 请求参数附加在 URL 后（如 `?id=123&name=foo`）
  - 数据可见（显示在浏览器地址栏）
  - 有长度限制（约 2048 字符）
  - 可被缓存/收藏/书签保存
  - **幂等操作**：多次执行结果相同（只读操作）

##### 2. `doPost()` 方法

java

```
@Override
protected void doPost(HttpServletRequest req, HttpServletResponse resp) {
    // 处理 POST 请求的逻辑
}
```

- **作用**：专门处理 HTTP **POST** 请求
- **典型场景**：
  - 表单提交指定 `method="POST"`
  - 文件上传
  - 敏感数据提交（登录/支付）
  - AJAX 数据提交
- **特点**：
  - 请求参数通过请求体传输（不在 URL 中）
  - 数据不可见（不显示在地址栏）
  - 无长度限制（适合大数据量）
  - 不可被缓存/收藏
  - **非幂等操作**：每次执行可能改变服务器状态（如创建订单）

#### 重定向

在 Java Servlet 中，**重定向（Redirect）** 是一种常见的 Web 导航技术，它涉及 `HttpServletRequest` 和 `HttpServletResponse` 对象，但主要由 `HttpServletResponse` 对象驱动。它指的是**指示客户端（通常是浏览器）向一个完全不同的 URL 发起一个新的请求**。

##### 重定向的核心机制（使用 `HttpServletResponse`）

1. **服务器端指令：** 当 Servlet 处理一个请求（`request`）时，它决定需要将客户端引导到另一个资源（可以是另一个 Servlet、JSP、HTML 页面，甚至是外部网站）。
2. **设置状态码和 Location 头：** Servlet 调用 `response.sendRedirect(String location)` 方法。
   - 这个方法会自动设置 HTTP 响应的状态码为 `302`（Found / Temporary Redirect）或 `307`（Temporary Redirect），表明这是一个临时重定向（现代浏览器/规范更倾向于使用 307/308 来保证方法不变）。如果需要永久重定向，可以手动设置状态码 `301` (Moved Permanently) 或 `308` (Permanent Redirect) 和 `Location` 头。
   - 它**必须**设置 `Location` 响应头，其值就是客户端应该去请求的新 URL。
3. **发送响应：** 包含 `302/307` 状态码和 `Location` 头的响应被发送回客户端（浏览器）。
4. **客户端发起新请求：** 客户端（浏览器）接收到这个响应，**识别到状态码是 3xx 并看到 `Location` 头**。
5. **自动导航：** 浏览器**自动**、**立即**向 `Location` 头指定的新 URL 发起一个**全新的 HTTP GET 请求**（即使原始请求是 POST，新请求默认也是 GET）。
6. **新请求处理：** 服务器接收到这个新的请求，由相应的资源（Servlet/JSP等）处理并生成最终响应给客户端。

##### 关键特性

- **两次请求：** 涉及两次完全独立的 HTTP 请求/响应循环。第一个请求由初始 Servlet 处理并返回重定向指令；第二个请求由目标资源处理。
- **浏览器参与：** 重定向是客户端行为，需要浏览器的配合来发起新请求。
- **URL 改变：** 浏览器地址栏中的 URL 会更新为 `Location` 头指定的新 URL。
- **数据隔离：** 第一个请求 (`request`) 中设置的属性（通过 `request.setAttribute()`）**不会**传递到第二个请求中。因为这是两个独立的 `HttpServletRequest` 对象。**如果需要传递数据，必须使用 URL 参数（附加到重定向 URL 后面）、Session (`HttpSession`) 或 Cookies。**
- **目标灵活：** 目标 URL 可以是同一个 Web 应用内的资源，也可以是另一个 Web 应用，甚至是完全不同的域（网站）。`sendRedirect()` 的参数可以是相对路径（相对于当前请求的 URL）或绝对路径（包含协议、域名、端口和应用上下文路径的完整 URL）。容器通常会将相对路径转换为绝对 URL。
- **主要方法：** `response.sendRedirect(location)`

##### 与另一个重要概念的区别：**请求转发（Forward）**

用户问题中提到的“另一个”，最核心、最常与重定向混淆的概念就是 **请求转发（Forward）**。它们都是服务器端控制导航的方式，但机制和用途截然不同：

| 特性           | 重定向 (Redirect)                                            | 请求转发 (Forward)                                           |
| :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **机制**       | **客户端行为**。服务器发送指令，**浏览器发起新请求**。       | **服务器内部行为**。服务器将请求**在内部移交**给另一个资源处理。 |
| **请求次数**   | **两次**独立的请求/响应。                                    | **一次**请求/响应。                                          |
| **浏览器感知** | **可见**。浏览器地址栏 URL 改变为新 URL。                    | **透明**。浏览器地址栏 URL **保持不变**（显示初始请求的 URL）。 |
| **数据共享**   | **不共享**。第一个请求的 `request` 属性丢失。需通过 URL 参数、Session、Cookies 传递。 | **共享**。使用同一个 `request` 对象，属性 (`setAttribute/getAttribute`) 在转发链中传递。 |
| **目标限制**   | **任意 URL**（同应用、不同应用、不同域名）。                 | **仅限于同一 Web 应用上下文（Context）内的资源**。           |
| **HTTP 方法**  | 新请求**默认总是 GET**（无论原始请求是什么方法）。           | **保持原始请求方法**（POST 转发后仍是 POST）。               |
| **性能**       | 稍慢（涉及额外的客户端往返、网络延迟）。                     | 更快（纯服务器内部操作，无额外网络往返）。                   |
| **主要方法**   | `response.sendRedirect(location)`                            | `request.getRequestDispatcher(path).forward(request, response)` |
| **状态码**     | 返回 `3xx` (如 302, 307) + `Location` 头。                   | 服务器内部处理，最终返回 `200` OK (或目标资源设置的状态码)。 |
| **典型场景**   | * 登录后跳转到主页。 * 表单提交成功后跳转防止重复提交。 * 将用户引导到外部站点。 * 旧 URL 迁移到新 URL。 | * MVC 模式：Servlet (Controller) 处理请求，转发给 JSP (View) 渲染。 * 将请求分派给专门的处理器（如处理 Header/Footer）。 * 需要共享请求处理结果（模型数据）到视图层。 |

##### 总结

- **重定向 (`response.sendRedirect()`)**：告诉浏览器“请去另一个地方找你要的东西”。浏览器收到指令后，会主动发起一个全新的 GET 请求到新地址。结果是**两次请求，URL 改变，原始请求数据不传递**。适用于导航到新位置、防止重复提交、跨应用/域跳转。
- **请求转发 (`request.getRequestDispatcher().forward()`)**：告诉服务器“请把这个请求交给另一个伙计处理，处理完直接回复给客户端”。整个过程发生在服务器内部，浏览器完全不知情。结果是**一次请求，URL 不变，原始请求数据可传递**。适用于服务器端协作处理请求、MVC 视图渲染。

理解这两者的区别对于设计正确的 Web 应用导航流程、数据流和用户体验至关重要。选择使用哪种方式取决于你的具体需求：是否需要改变浏览器地址、是否需要跨应用跳转、是否需要保留原始请求数据等。

#### getAttribut和setAttribut方法

好的，我们来详细讲解 Servlet 中的 `getAttribute()` 和 `setAttribute()` 方法。它们是**在请求作用域 (`HttpServletRequest`)、会话作用域 (`HttpSession`) 和应用作用域 (`ServletContext`) 中存储和检索数据对象的核心机制**，用于在 Web 应用的不同组件（Servlet, JSP, Filter）之间传递信息。

**核心概念：**

1. **作用域 (Scope):** 指的是数据对象有效的生命周期和可访问的范围。
2. **属性 (Attribute):** 指的就是你存储在特定作用域对象（`request`, `session`, `application`）中的一个命名数据对象。这个数据对象可以是任何 Java 对象 (`Object` 类型)。
3. **键 (Key):** 一个唯一的字符串 (`String`)，用于标识和检索特定的属性。

------

**一、`setAttribute(String name, Object value)`**

- **作用：** 将一个 Java 对象 (`value`) 以指定的名称 (`name`) **绑定（存储）**到特定的作用域对象中。

- **参数：**

  - `name`: 属性的名称（键），是一个唯一的字符串。
  - `value`: 要存储的数据对象本身（可以是 `String`, `Integer`, 自定义 `User` 对象, `List`, `Map` 等任何 `Object` 的子类）。

- **特点：**

  - **存储数据：** 这是主要的存储方式。
  - **覆盖同名属性：** 如果指定的 `name` 在当前作用域中已经存在对应的属性，那么旧的 `value` 会被新的 `value` **覆盖**。
  - **作用域决定生命周期和可见性：**
    - **`request.setAttribute(...)`:** 数据在整个 **一次 HTTP 请求处理周期** 内有效。包括请求经过的 Servlet、Filter 以及最终通过 `RequestDispatcher.forward(...)` 转发的 JSP 或 Servlet。**重定向 (`sendRedirect`) 后，新的请求会创建一个新的 `request` 对象，原 `request` 中的属性会丢失。**
    - **`session.setAttribute(...)`:** 数据在整个 **用户会话** 期间有效（从用户首次访问服务器建立 Session 开始，直到 Session 超时或显式调用 `session.invalidate()` 销毁）。同一个用户（浏览器）的多次请求（即使是重定向后的新请求）都可以访问这些属性。常用于存储用户登录状态、购物车内容等。
    - **`application.setAttribute(...)`:** 数据在整个 **Web 应用** 的生命周期内有效（从应用启动到应用停止或服务器关闭）。所有访问该应用的用户的所有请求都可以访问这些属性。常用于存储全局配置信息、共享资源（如数据库连接池的引用）。**需要特别注意线程安全！**

- **示例：**

  java

  ```
  // 在 Servlet 的 doGet/doPost 方法中
  // 存储到 request 作用域
  String message = "操作成功！";
  request.setAttribute("statusMessage", message); // 存储字符串
  User currentUser = new User("John Doe", "john@example.com");
  request.setAttribute("user", currentUser); // 存储自定义对象
  List<String> products = Arrays.asList("手机", "电脑", "耳机");
  request.setAttribute("productList", products); // 存储集合
  
  // 存储到 session 作用域 (用户登录成功后)
  HttpSession session = request.getSession(); // 获取或创建 session
  session.setAttribute("loggedInUser", currentUser);
  
  // 存储到 application 作用域 (通常在 ServletContextListener 或 Servlet 初始化时)
  ServletContext application = getServletContext();
  application.setAttribute("appConfig", someConfigObject);
  ```

------

**二、`Object getAttribute(String name)`**

- **作用：** 从特定的作用域对象中根据指定的名称 (`name`) **检索（获取）** 之前存储的属性值。

- **参数：**

  - `name`: 要检索的属性的名称（键）。

- **返回值：**

  - 如果找到指定名称的属性，则返回与该名称绑定的 `Object`。
  - 如果找不到指定名称的属性，则返回 `null`。

- **特点：**

  - **检索数据：** 这是主要的检索方式。
  - **需要类型转换：** 因为返回值是 `Object` 类型，你需要将其 **强制转换** 回你存储时的实际类型。
  - **作用域决定从哪里检索：**
    - **`request.getAttribute(...)`:** 从当前的 `HttpServletRequest` 对象中查找属性。
    - **`session.getAttribute(...)`:** 从与当前请求关联的 `HttpSession` 对象中查找属性。
    - **`application.getAttribute(...)`:** 从当前的 `ServletContext` 对象中查找属性。

- **示例：**

  java

  ```
  // 在另一个 Servlet 或 JSP 中 (假设是同一个请求或同一个会话或同一个应用)
  // 从 request 作用域获取
  String message = (String) request.getAttribute("statusMessage"); // 强制转换
  User user = (User) request.getAttribute("user"); // 强制转换
  List<String> products = (List<String>) request.getAttribute("productList"); // 强制转换
  
  // 从 session 作用域获取
  HttpSession session = request.getSession(false); // 获取现有 session (不创建新的)
  if (session != null) {
      User loggedInUser = (User) session.getAttribute("loggedInUser");
      if (loggedInUser != null) {
          // 用户已登录
      }
  }
  
  // 从 application 作用域获取
  ServletContext application = getServletContext();
  AppConfig config = (AppConfig) application.getAttribute("appConfig");
  ```

------

**三、`removeAttribute(String name)`**

- **作用：** 从特定的作用域对象中 **移除** 指定名称 (`name`) 的属性及其关联的值。

- **参数：**

  - `name`: 要移除的属性的名称。

- **特点：**

  - 如果指定名称的属性存在，则移除它。
  - 如果不存在，则该方法不执行任何操作（静默失败）。
  - 常用于清理不再需要的数据，特别是在 `session` 中（如用户登出时移除用户对象）。

- **示例：**

  java

  ```
  // 用户登出
  HttpSession session = request.getSession(false);
  if (session != null) {
      session.removeAttribute("loggedInUser"); // 移除用户属性
      // session.invalidate(); // 或者直接销毁整个 session
  }
  ```

------

**四、与 `getParameter()` 的关键区别**

- **`request.getParameter(String name)`：**
  - **来源：** 专门用于**获取 HTTP 请求参数**。
  - **参数来源：** 来自 URL 查询字符串 (如 `?id=123`) 或 HTML 表单提交 (`<input>`, `<select>`, `<textarea>`) 的 `POST`/`GET` 请求体。
  - **数据类型：** 返回 **`String`** 类型或 `null`（如果参数不存在）。只能获取字符串值。对于多值参数（如复选框），使用 `getParameterValues(String name)` 返回 `String[]`。
  - **只读：** 你不能通过 `request` 对象设置 (`set`) 参数。参数是由客户端发送的。
  - **作用域：** 只与当前请求相关。
- **`getAttribute()` / `setAttribute()`：**
  - **来源：** 是**服务器端编程机制**，用于在服务器内部的不同组件之间（Servlet、JSP、Filter）**传递任意 Java 对象**。
  - **数据来源：** 数据是由服务器端代码（如 Servlet）使用 `setAttribute()` 方法显式设置的。
  - **数据类型：** 可以存储和获取**任何 Java 对象 (`Object`)**。
  - **可读写：** 通过 `setAttribute()` 设置，`getAttribute()` 读取，`removeAttribute()` 移除。
  - **作用域：** 可以是 `request`, `session`, `application`，决定了数据的生命周期和可见范围。

**简单比喻：**

- **`getParameter()`** 就像从客户寄来的信封里（HTTP请求）取出信件内容（参数值）。你只能读信封里写好的内容（字符串），不能往信封里塞新纸（设置参数）。
- **`setAttribute()` / `getAttribute()`** 就像你在处理客户信件（请求）时，自己准备了一些便签纸（属性），写上名字（key）和内容（value，可以是复杂对象），贴在自己的办公桌（request）、客户的专属文件夹（session）或办公室的公告板（application）上，方便自己或同事后续处理时查阅或修改。

**总结：**

- **`setAttribute(name, value)`** 用于在 `request`, `session`, 或 `application` 作用域中存储数据对象。
- **`getAttribute(name)`** 用于从这些作用域中检索数据对象（需要强制转换）。
- **`removeAttribute(name)`** 用于移除不再需要的属性。
- 它们与 `getParameter()` 有本质区别：`getParameter()` 用于获取**客户端发送的请求参数（字符串）**，而 `get/setAttribute()` 用于在**服务器端组件间传递任意对象**。
- **理解作用域 (`request`, `session`, `application`) 是正确使用这些方法的关键**，它决定了数据何时创建、何时销毁、谁能访问。选择错误的作用域会导致数据泄露（如用户A看到用户B的数据）、内存浪费或数据丢失。









### JSP

#### 语法

![image-20250721155157516](../AppData/Roaming/Typora/typora-user-images/image-20250721155157516.png)

![image-20250721155936937](../AppData/Roaming/Typora/typora-user-images/image-20250721155936937.png)



![image-20250721160334467](../AppData/Roaming/Typora/typora-user-images/image-20250721160334467.png)

![image-20250721160725606](../AppData/Roaming/Typora/typora-user-images/image-20250721160725606.png)

#### JSP原理

![image-20250721162557606](../AppData/Roaming/Typora/typora-user-images/image-20250721162557606.png)

#### JSP内置对象

![image-20250721163635226](../AppData/Roaming/Typora/typora-user-images/image-20250721163635226.png)



![image-20250721172652634](../AppData/Roaming/Typora/typora-user-images/image-20250721172652634.png)

![image-20250721173040154](../AppData/Roaming/Typora/typora-user-images/image-20250721173040154.png)









![image-20250721173014096](../AppData/Roaming/Typora/typora-user-images/image-20250721173014096.png)

![image-20250721172952984](../AppData/Roaming/Typora/typora-user-images/image-20250721172952984.png)

#### JSP指令

![image-20250721203740911](../AppData/Roaming/Typora/typora-user-images/image-20250721203740911.png)

![image-20250721204044999](../AppData/Roaming/Typora/typora-user-images/image-20250721204044999.png)

![image-20250721204404641](../AppData/Roaming/Typora/typora-user-images/image-20250721204404641.png)

#### 状态码

![image-20250721205101020](../AppData/Roaming/Typora/typora-user-images/image-20250721205101020.png)

#### EL表达式

![image-20250721211754250](../AppData/Roaming/Typora/typora-user-images/image-20250721211754250.png)

![image-20250721214116681](../AppData/Roaming/Typora/typora-user-images/image-20250721214116681.png)

![image-20250721214340771](../AppData/Roaming/Typora/typora-user-images/image-20250721214340771.png)

![image-20250721220009262](../AppData/Roaming/Typora/typora-user-images/image-20250721220009262.png)

![image-20250721220759551](../AppData/Roaming/Typora/typora-user-images/image-20250721220759551.png)

#### JSTL数据库

![image-20250722173843037](../AppData/Roaming/Typora/typora-user-images/image-20250722173843037.png)

![image-20250722173932045](../AppData/Roaming/Typora/typora-user-images/image-20250722173932045.png)

![image-20250722182826903](../AppData/Roaming/Typora/typora-user-images/image-20250722182826903.png)

![image-20250722183046165](../AppData/Roaming/Typora/typora-user-images/image-20250722183046165.png)

![image-20250722183305212](../AppData/Roaming/Typora/typora-user-images/image-20250722183305212.png)

![image-20250722184941672](../AppData/Roaming/Typora/typora-user-images/image-20250722184941672.png)

![image-20250722185508820](../AppData/Roaming/Typora/typora-user-images/image-20250722185508820.png)

![image-20250722185644461](../AppData/Roaming/Typora/typora-user-images/image-20250722185644461.png)

### Filter和Listener

#### 会话跟踪技术

![image-20250722221428259](../AppData/Roaming/Typora/typora-user-images/image-20250722221428259.png)

#### cookie

##### 理论

流程图

![image-20250722221812635](../AppData/Roaming/Typora/typora-user-images/image-20250722221812635.png)

![image-20250722221547114](../AppData/Roaming/Typora/typora-user-images/image-20250722221547114.png)

![image-20250722223833456](../AppData/Roaming/Typora/typora-user-images/image-20250722223833456.png)

![image-20250722230449113](../AppData/Roaming/Typora/typora-user-images/image-20250722230449113.png)

##### 代码实现

![image-20250722231204749](../AppData/Roaming/Typora/typora-user-images/image-20250722231204749.png)

![image-20250722231128265](../AppData/Roaming/Typora/typora-user-images/image-20250722231128265.png)

![image-20250722231408163](../AppData/Roaming/Typora/typora-user-images/image-20250722231408163.png)

#### session

##### 理论

![image-20250722231807635](../AppData/Roaming/Typora/typora-user-images/image-20250722231807635.png)

![image-20250722233652884](../AppData/Roaming/Typora/typora-user-images/image-20250722233652884.png)

![image-20250722233919467](../AppData/Roaming/Typora/typora-user-images/image-20250722233919467.png)

![image-20250722234213388](../AppData/Roaming/Typora/typora-user-images/image-20250722234213388.png)

##### 代码解释

**(1) 测试链接**

html

```
<a href="test">test-cookie</a>
```

- 超链接指向相对路径 `test`，点击后会访问该URL（通常由后端Servlet处理，用于测试Cookie功能）。

**(2) 登录表单**

html

```
<form action="/login" method="post">
  username: <input type="text" name="uname"><br>
  password: <input type="password" name="pass"><br>
  <input type="submit" value="login">
</form>
```

- **`<form action="/login" method="post">`**
  表单提交到绝对路径 `/login`，使用 **POST 方法**（适合敏感数据如密码）。

- **用户名输入框**
  `<input type="text" name="uname">`：文本输入框，后端通过参数名 `uname` 获取值。

- **密码输入框**
  `<input type="password" name="pass">`：密码输入框（内容掩码显示），参数名为 `pass`。

- **提交按钮**
  `<input type="submit" value="login">`：点击后提交表单数据到 `/login`。

  ![image-20250723185230669](../AppData/Roaming/Typora/typora-user-images/image-20250723185230669.png)

![image-20250723185433821](../AppData/Roaming/Typora/typora-user-images/image-20250723185433821.png)

![image-20250723185523704](../AppData/Roaming/Typora/typora-user-images/image-20250723185523704.png)

![image-20250723185723552](../AppData/Roaming/Typora/typora-user-images/image-20250723185723552.png)

#### cookie与session

![image-20250723190744996](../AppData/Roaming/Typora/typora-user-images/image-20250723190744996.png)

#### Filter

##### 介绍

执行顺序123然后321

![image-20250723190845128](../AppData/Roaming/Typora/typora-user-images/image-20250723190845128.png)

![image-20250723191307811](../AppData/Roaming/Typora/typora-user-images/image-20250723191307811.png)

![image-20250723191538132](../AppData/Roaming/Typora/typora-user-images/image-20250723191538132.png)

##### 代码实现

![c0654b46b4739e7468e9297fad6b01ae](../Documents/Tencent Files/1759751014/nt_qq/nt_data/Pic/2025-07/Ori/c0654b46b4739e7468e9297fad6b01ae.png)

![image-20250723210545329](../AppData/Roaming/Typora/typora-user-images/image-20250723210545329.png)

注意这里的先后顺序

![image-20250723211849038](../AppData/Roaming/Typora/typora-user-images/image-20250723211849038.png)

![image-20250723212056917](../AppData/Roaming/Typora/typora-user-images/image-20250723212056917.png)

#### 监听器

![image-20250723212304489](../AppData/Roaming/Typora/typora-user-images/image-20250723212304489.png)

![image-20250723212702340](../AppData/Roaming/Typora/typora-user-images/image-20250723212702340.png)

![image-20250723212915603](../AppData/Roaming/Typora/typora-user-images/image-20250723212915603.png)

![image-20250723213326036](../AppData/Roaming/Typora/typora-user-images/image-20250723213326036.png)

![image-20250723213351241](../AppData/Roaming/Typora/typora-user-images/image-20250723213351241.png)

#### MVC设计模式

##### 介绍

![image-20250724202120401](../AppData/Roaming/Typora/typora-user-images/image-20250724202120401.png)

![image-20250724203546723](../AppData/Roaming/Typora/typora-user-images/image-20250724203546723.png)

#### 三层架构

![image-20250724211824544](../AppData/Roaming/Typora/typora-user-images/image-20250724211824544.png)

![image-20250724211950946](../AppData/Roaming/Typora/typora-user-images/image-20250724211950946.png)

## 重要的知识点

#### 1.@RequestBody将json封装在对象里

在 **Spring Boot（Spring MVC）** 里，`@RequestBody` 的作用是：

👉 **把 HTTP 请求体（Request Body）里的 JSON、XML 或表单数据，自动反序列化为 Java 对象，并注入到方法参数中。**

------

###### 🔹 为什么要用 `@RequestBody`？

- HTTP 请求有两部分：**请求头 (headers)** 和 **请求体 (body)**。
- 当客户端发送 **POST/PUT** 请求时，通常会把数据放在请求体里（JSON 比较常见）。
- Spring 默认只能自动解析 **表单键值对（x-www-form-urlencoded）** 这种数据，
  如果你传的是 **JSON**，就需要用 `@RequestBody` 告诉 Spring：**请把请求体里的 JSON 转成 Java 对象**。

------

###### 🔹 示例

###### 1. 不使用 `@RequestBody`（传统表单方式）

```
@PostMapping("/addUser")
public String addUser(String name, Integer age) {
    return "用户: " + name + " 年龄: " + age;
}
```

请求方式（表单）：

```
POST /addUser
Content-Type: application/x-www-form-urlencoded

name=张三&age=20
```

------

###### 2. 使用 `@RequestBody`（JSON 方式）

```
@RestController
public class UserController {
    @PostMapping("/addUser")
    public String addUser(@RequestBody User user) {
        return "用户: " + user.getName() + " 年龄: " + user.getAge();
    }
}
```

`User` 类：

```
public class User {
    private String name;
    private Integer age;
    // getter/setter
}
```

请求方式（JSON 请求体）：

```
POST /addUser
Content-Type: application/json

{
  "name": "张三",
  "age": 20
}
```

Spring 会自动用 **Jackson**（默认的 JSON 解析库）把 JSON 解析成 `User` 对象。

------

######🔹 小结

- `@RequestBody`：取 **请求体数据**，并自动转换为 Java 对象。
- 常用于 `POST` / `PUT` 请求。
- 依赖 `HttpMessageConverter`（默认用 Jackson 处理 JSON）。







#### 2.@RestController

**`@RestController`** 是 Spring Framework 4.0 引入的一个复合注解，它的作用是简化 **RESTful Web 服务**的开发。

它实际上是两个注解的组合：

1. `@Controller`
2. `@ResponseBody`



**`@Controller` 的作用**



`@Controller` 用于标识一个类是 Spring MVC 的控制器。在传统的 MVC 架构中，`@Controller` 负责处理客户端的请求，并将请求分发给相应的服务层进行处理，然后返回一个视图名（如 JSP、Thymeleaf 模板）。



**`@ResponseBody` 的作用**



`@ResponseBody` 通常标注在方法或类上，它的作用是告诉 Spring **不要将方法的返回值解析为视图名称**，而是将返回值直接作为 **HTTP 响应体**（Response Body）返回给客户端。

Spring 会使用内置的 HTTP 消息转换器（`HttpMessageConverter`）来处理这个返回值，通常是将其转换为 **JSON** 或 **XML** 格式。这对于构建返回数据的 API 服务非常重要。





#### 3.基于SpringBoot官方骨架创建的，这些字段会保留

![image-20250811005605843](../AppData/Roaming/Typora/typora-user-images/image-20250811005605843.png)





#### 4.传参的情况

**它可以自动把id提取出来**

![image-20250811010857934](../AppData/Roaming/Typora/typora-user-images/image-20250811010857934.png)

#### 5.@Component的作用(@Service)

在Spring Boot中，`@Component` 注解的作用是**将一个类标记为Spring组件**。

简单来说，当你在一个类上使用 `@Component` 注解时，你就是在告诉Spring框架：“嘿，请管理这个类。在应用启动时，请为我创建一个它的实例（也就是一个 Bean），并把它放到你的容器（Spring IoC Container）里。”

这样一来，这个被标记的类就成为了Spring可以识别和管理的**组件**。其他地方需要使用这个类的实例时，Spring就可以通过**依赖注入**（Dependency Injection）的方式，将它自动装配进来，而不需要你手动去创建和管理实例。

除了 `@Component`，Spring还提供了几个更具特定语义的衍生注解，它们的作用和 `@Component` 基本相同，但用在不同的分层架构中，让代码更清晰、更易懂：

- `@Controller`: 用于标记处理Web请求的类，通常在**控制层**（Controller layer）使用。
- `@Service`: 用于标记包含业务逻辑的类，通常在**服务层**（Service layer）使用。
- `@Repository`: 用于标记处理数据持久化（例如与数据库交互）的类，通常在**数据访问层**（Data access layer）使用。

总的来说，这四个注解的作用都是一样的：将类注册成Spring的组件。选择使用哪一个取决于这个组件在你的应用中扮演的角色。这不仅有助于代码组织，也让开发人员能更快地理解每个类的职责。



#### 6.Autowired

在 Java Spring Boot 中， @Autowired  是 Spring 框架提供的核心注解之一，主要作用是实现依赖的自动注入，帮助开发者简化对象之间依赖关系的管理。

具体来说，它的作用可以拆解为：

1. 自动关联依赖对象
   当一个类（比如  Service 、 Controller  等）需要依赖另一个类的实例时（比如  Service  依赖  Dao ），不需要手动通过  new  创建依赖对象，只需在依赖字段、构造方法或 setter 方法上添加  @Autowired ，Spring 容器会自动从容器中找到匹配的对象，并注入到当前类中。示例：
   @Service
   public class UserService {
    // 自动注入 UserDao 实例
    @Autowired
    private UserDao userDao;

    public void addUser() {
        userDao.save(); // 直接使用注入的 userDao
    }
   }

2. 降低代码耦合度
   传统方式中，需要手动创建依赖对象（如  userDao = new UserDao() ），导致类与类之间强耦合。 @Autowired  让依赖关系由 Spring 容器管理，开发者只需关注业务逻辑，无需关心对象的创建和关联，更符合“依赖倒置原则”。

3. 支持多种注入方式

- 字段注入：直接在成员变量上添加  @Autowired （最常用）。

- 构造方法注入：在构造方法上添加  @Autowired ，Spring 会在创建当前对象时，自动注入构造方法的参数。
  @Service
  public class UserService {
    private UserDao userDao;

    // 构造方法注入
    @Autowired
    public UserService(UserDao userDao) {
        this.userDao = userDao;
    }
  }

- setter 方法注入：在 setter 方法上添加  @Autowired ，Spring 会调用该方法注入依赖。

4. 默认按类型匹配（byType）
   Spring 容器会根据被注入字段的类型（如  UserDao ），在容器中查找相同类型的 bean 并注入。如果存在多个同类型的 bean，会报错，此时需配合  @Qualifier  注解指定具体 bean 的名称：
   @Autowired
   @Qualifier("userDaoImpl") // 指定注入名称为 userDaoImpl 的 bean
   private UserDao userDao;

5. 可配置是否必须注入
   @Autowired  有个  required  属性（默认  true ），表示依赖必须存在，否则会报错。若设为  false ，则当依赖不存在时，注入  null ：
   @Autowired(required = false)
   private UserDao userDao;


总之， @Autowired  是 Spring 实现“控制反转（IOC）”和“依赖注入（DI）”的关键注解，极大简化了对象依赖的管理，是 Spring Boot 开发中最常用的注解之一。

#### 7.RequestParam设置默认值

![image-20250811140433455](../AppData/Roaming/Typora/typora-user-images/image-20250811140433455.png)

在 Spring Boot 中，`@RequestParam` 是一个非常常用的注解，它的主要作用是**将 HTTP 请求中的参数绑定到你的控制器（Controller）方法的参数上**。简单来说，就是当你的浏览器发送一个带参数的请求到你的服务器时，Spring Boot 框架能通过 `@RequestParam` 自动把这些参数的值“抓取”过来，并赋值给你方法中定义的变量，这样你就可以在业务逻辑中直接使用这些参数了。



###### 1. 最简单的用法



假设你有一个接口，需要接收一个名为 `name` 的字符串参数。

Java

```
@GetMapping("/hello")
public String hello(@RequestParam String name) {
    return "Hello, " + name + "!";
}
```

当你访问 `http://localhost:8080/hello?name=Gemini` 时，Spring Boot 会找到 `name=Gemini` 这个参数，然后把它赋值给 `hello` 方法里的 `name` 变量。所以，最终你会得到一个返回结果："Hello, Gemini!"。



###### 2. 参数名不一致时的用法



如果你的请求参数名和方法参数名不一致，你可以通过 `@RequestParam` 的 `value`（或者 `name`）属性来指定。

Java

```
@GetMapping("/user")
public String getUser(@RequestParam("userId") String id) {
    return "User ID is: " + id;
}
```

在这种情况下，你需要访问 `http://localhost:8080/user?userId=123`，而不是 `?id=123`。



###### 3. 设定参数为非必传（可选）



默认情况下，使用 `@RequestParam` 标记的参数都是**必传**的。如果请求中没有这个参数，Spring Boot 会抛出一个 `MissingServletRequestParameterException` 异常。

如果你想让一个参数变成可选的，可以通过设置 `required = false`。

Java

```
@GetMapping("/greet")
public String greet(@RequestParam(value = "name", required = false) String name) {
    if (name == null || name.isEmpty()) {
        return "Hello, Guest!";
    }
    return "Hello, " + name + "!";
}
```

现在，当你访问 `http://localhost:8080/greet`（没有带参数）时，`name` 参数会被赋值为 `null`，程序会正常执行。当你访问 `http://localhost:8080/greet?name=Lily` 时，`name` 的值就是 "Lily"。

------



###### 4. 设定默认值



当你把参数设为可选后，你还可以通过 `defaultValue` 属性为它指定一个默认值，这样就不用再手动判断 `null` 了。

Java

```
@GetMapping("/search")
public String search(@RequestParam(defaultValue = "1") int page) {
    return "Searching on page: " + page;
}
```

在这个例子中，如果你访问 `http://localhost:8080/search`，`page` 的值会自动变成 `1`。如果你访问 `http://localhost:8080/search?page=5`，`page` 的值就是 `5`。

------



###### 5. 接收多个同名参数



如果你的请求中有多个同名的参数（比如一个复选框），你可以使用一个集合类型来接收它们。

Java

```
@GetMapping("/items")
public String getItems(@RequestParam List<String> itemIds) {
    return "Selected items: " + String.join(", ", itemIds);
}
```

当你访问 `http://localhost:8080/items?itemIds=101&itemIds=102&itemIds=103` 时，`itemIds` 将会是一个包含 `["101", "102", "103"]` 的列表。





#### 8.查看并下载依赖的网站

https://mvnrepository.com/

#### 9.注意重要判断函数

false非空，true空

![image-20250813165334804](../AppData/Roaming/Typora/typora-user-images/image-20250813165334804.png)

#### 10.获取主键Id

![image-20250814133036081](../AppData/Roaming/Typora/typora-user-images/image-20250814133036081.png)

![image-20250814175019118](../AppData/Roaming/Typora/typora-user-images/image-20250814175019118.png)

![image-20250814175047241](../AppData/Roaming/Typora/typora-user-images/image-20250814175047241.png)

#### 11.防止其他事务回滚影响

![image-20250814225749116](../AppData/Roaming/Typora/typora-user-images/image-20250814225749116.png)

![image-20250814230453904](../AppData/Roaming/Typora/typora-user-images/image-20250814230453904.png)

#### 12.某些东西可以放在配置文件中

两种方法

![image-20250816161530011](../AppData/Roaming/Typora/typora-user-images/image-20250816161530011.png)

![image-20250816160143157](../AppData/Roaming/Typora/typora-user-images/image-20250816160143157.png)

#### 13.内连接和外连接

一个是交集，一个是并集（就是left join或者join的问题）

#### 14.修改方法

先删后存

#### 15.《set》和《where》标签

![image-20250817120250975](../AppData/Roaming/Typora/typora-user-images/image-20250817120250975.png)

#### 16.全局异常处理

![image-20250817204303527](../AppData/Roaming/Typora/typora-user-images/image-20250817204303527.png)



**这里的错误信息会从下往上检查是哪个问题（就是从最子类检查到最父类）**

![image-20250817210029213](../AppData/Roaming/Typora/typora-user-images/image-20250817210029213.png)

![image-20250817210830728](../AppData/Roaming/Typora/typora-user-images/image-20250817210830728.png)

#### 17.注意SQL细节

如果您使用 MyBatis 插入一个完整的对象，MyBatis 会自动处理字段映射。

XML

```
<insert id="insert" parameterType="com.it.pojo.Clazz">
    insert into clazz
    (id, name, room, begin_date, end_date, master_id, subject, create_time, update_time)
    values
    (#{id}, #{name}, #{room}, #{beginDate}, #{endDate}, #{masterId}, #{subject}, #{createTime}, #{updateTime})
</insert>
```

**重要提示：**

- 如果您的 `id` 字段是数据库自动生成的（例如，使用 `AUTO_INCREMENT`），则应该在 SQL 语句中省略 `id` 字段。
- 如果 `createTime` 和 `updateTime` 字段是由数据库自动填充的，您也应该在插入时省略它们。
- 这个 `insert` 语句假设您有一个方法，例如 `insert(Clazz clazz)`，它将一个 `Clazz` 对象作为参数。MyBatis 会自动将 `Clazz` 对象中的属性值映射到 `#{...}` 占位符。

#### 18.@Bean

在 **Spring / Spring Boot** 里，`@Bean` 的作用就是：

👉 **告诉 Spring 容器：我要往 IOC 容器里注册一个 Bean（对象），并交给 Spring 来管理它的生命周期。**

------

##### 🔹 基本概念

- **Bean**：就是由 Spring 容器管理的对象。

- 在以前我们写 `applicationContext.xml` 的时候，要手动写：

  ```
  <bean id="myService" class="com.example.MyService"/>
  ```

- 现在用 Java 配置时，只要写个方法加上 `@Bean`，返回一个对象，Spring 就会把这个对象放进容器里。

------

##### 🔹 示例

```
@Configuration  // 表示这是一个配置类，等价于一个 Spring XML 配置文件
public class AppConfig {

    @Bean   // 向 Spring 容器注册一个 Bean
    public MyService myService() {
        return new MyService(); // 这个对象会被 Spring 容器托管
    }
}
```

这样，Spring 容器里就有了一个名字为 `myService` 的 Bean。
 你就可以在别的地方注入使用：

```
@RestController
public class TestController {
    private final MyService myService;

    public TestController(MyService myService) {
        this.myService = myService;
    }

    @GetMapping("/hello")
    public String hello() {
        return myService.sayHello();
    }
}
```

------

##### 🔹 细节

1. **Bean 名字**

   - 默认：方法名就是 Bean 的名字（上例中是 `myService`）。

   - 也可以指定：

     ```
     @Bean("customService")
     public MyService myService() { ... }
     ```

2. **和 @Component 的区别**

   - `@Component`：直接标在类上，由 **类扫描** 注册成 Bean。
   - `@Bean`：标在 **方法上**，手动指定返回的对象。
   - 一般 `@Component` 用在自己写的业务类；
     `@Bean` 用在第三方类或需要自己构造的对象。

3. **生命周期**

   - Spring 管理 Bean 的创建、初始化、销毁。
   - 可以配合 `@Scope("prototype")` 指定作用域。

------

✅ **一句话总结：**
 `@Bean` 就是 **注册一个方法返回的对象到 Spring 容器**，让它变成一个 Bean，后续可以在项目里通过依赖注入来使用







很多人一开始都会觉得：**有了 `@Component`，为啥还要 `@Bean`？**
 其实这两个注解虽然最终效果都是 **往 Spring 容器里注册一个 Bean**，但 **应用场景完全不同**。

------

##### 🔹 1. `@Component` 适用场景

- **你能改源码**，类是你自己写的。

- 直接在类上加：

  ```
  @Component
  public class MyService { ... }
  ```

- Spring 会自动通过 **包扫描** 发现并注册这个类为 Bean。

- 适合普通的业务逻辑类、Controller、Service、Repository 等。

------

##### 🔹 2. `@Bean` 适用场景

- **你不能改源码**，比如第三方库的类（`DataSource`、`RestTemplate` 等）。

- 或者 **实例化这个 Bean 需要额外逻辑**（构造参数、配置、初始化等）。

- 举例：

  ```
  @Configuration
  public class AppConfig {
      
      @Bean
      public RestTemplate restTemplate() {
          // 这里你可以定制化，比如加拦截器
          return new RestTemplate();
      }
  
      @Bean
      public DataSource dataSource() {
          HikariDataSource ds = new HikariDataSource();
          ds.setJdbcUrl("jdbc:mysql://localhost:3306/test");
          ds.setUsername("root");
          ds.setPassword("1234");
          return ds;
      }
  }
  ```

- 如果是第三方类（比如 `RestTemplate`），你不能在源码上加 `@Component`，只能用 `@Bean`。

------

##### 🔹 3. 二者关系

- `@Component` 走 **类扫描**。
- `@Bean` 走 **方法工厂**。
- 其实它们都只是 **不同的 Bean 定义方式**，最终效果一样：对象交给 Spring 容器管理。

------

##### 🔹 总结类比

- **`@Component`**：像是在类上打一个 “自动注册” 标签 → Spring 扫描到就帮你托管。
- **`@Bean`**：像是自己写了一段 “生产这个对象的方法” → 把方法返回的对象交给 Spring 托管。

------

👉 一句话：

- 如果是 **自己写的类** → 用 `@Component`（更简洁）。
- 如果是 **第三方类** 或 **需要复杂初始化的对象** → 用 `@Bean`。



#### 19.SQL小技巧

```
update_time timestamp not null default current_timestamp on update current_timestamp comment '更新时间',
```

- `timestamp`：这是数据类型。A`timestamp`存储日期和时间，通常采用 UTC 格式。这是一种追踪特定时刻的有效方法。
- `default current_timestamp`：这会将 的初始值设置`update_time`为插入新行时的当前时间戳。因此，`create_time`和`update_time`在新行首次创建时将保持不变。
- `on update current_timestamp`**：这是关键的区别。每当该行中的任何其他列发生更改时，**它都会自动将的值更新`update_time`为当前时间戳。这是一个非常有用的功能，无需在应用程序中编写额外的代码即可跟踪记录的修改。

------



 **`CONSTRAINT`**



```
constraint chk_phone_length check (char_length(phone) = 11)
```

- `constraint chk_phone_length`：这为约束提供了一个名称。命名后，如果需要，可以更轻松地管理、引用或删除约束。
- `check (...)`：这是一个**`CHECK`约束**。它定义了列中的数据必须满足的规则。如果您尝试插入或更新违反此规则的值的行，则操作将失败并返回错误。
- `char_length(phone) = 11`：这是规则。该`CHAR_LENGTH()`函数返回字符串中的字符数。此规则确保该`phone`列**必须恰好包含 11 个字符**。任何少于或多于 11 个字符的值都将被拒绝。

#### 20.简便写日期方法

```
@DateTimeFormat(pattern = "yyyy-MM-dd")
private LocalDate begin;
```

#### 21.WebConfig

![image-20250904215506470](../AppData/Roaming/Typora/typora-user-images/image-20250904215506470.png)

`@Configuration`: 这是一个 Spring 框架的注解，表明这个类是一个配置类。在 Spring 容器启动时，会扫描并加载这个类，并根据其中的配置来创建和配置 bean。（注意这个类没创建Bean，AAutowired下面是别人已经创建好的）。



`public void addInterceptors(InterceptorRegistry registry)`: 这是 `WebMvcConfigurer` 接口中的一个方法，用于注册拦截器。

- `registry.addInterceptor(tokeninterceptor)`: 将 `tokeninterceptor` 注册为一个拦截器。
- `.addPathPatterns("/**")`: 这个方法指定了拦截器要拦截的 URL 路径模式。`"/**"` 是一个通配符，表示拦截所有的 URL 路径。这意味着，当任何请求进入你的应用程序时，`Tokeninterceptor` 都会被执行。



这段代码的作用是**将一个名为 `Tokeninterceptor` 的拦截器注册到 Spring MVC 应用程序中，并让它拦截所有请求**。

#### 22.Interceptor拦截

```
public class Tokeninterceptor implements HandlerInterceptor
```

#### 23.Transactional方法

```
@Transactional(propagation = Propagation.REQUIRES_NEW)
```

1. **propagation = Propagation.REQUIRES_NEW 参数**：
   - 表示事务传播行为设置为 REQUIRES_NEW 模式。
   - 这意味着**每次调用此方法时都会创建一个全新的独立事务**。
   - 如果调用此方法的外层方法已经存在事务，则外层事务会被挂起，直到当前方法的新事务完成后再恢复。
2. **在当前代码中的应用场景**：
   - EmpLogServiceImpl 是一个日志服务实现类，insertLog 方法用于插入操作日志。
   - 使用 REQUIRES_NEW 传播特性，确保日志记录操作**不受外层业务事务的影响**。
   - 即使外层业务操作失败回滚，日志记录仍然会被成功保存，这对于系统审计、问题排查和数据追踪非常重要。

#### 24.动态sql

![image-20250910150548624](../AppData/Roaming/Typora/typora-user-images/image-20250910150548624.png)

![image-20250910150605339](../AppData/Roaming/Typora/typora-user-images/image-20250910150605339.png)

#### 25.配置类

在 Spring 里，想让某个对象被 IoC 容器管理，有两种常见方式：

1. **注解扫描（最常见）**
   在类上加 `@Component` / `@Service` / `@Controller`，Spring 会自动扫描并注册为 Bean。
2. **显式注册（配置类方式）**
   通过一个配置类，用 `@Bean` 方法手动告诉 Spring：“这个方法返回的对象，要放进 IoC 容器里，成为一个 Bean”。

------

##### 2. 配置类显式注册 Bean 的写法

```
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration  // 表示这是一个配置类，相当于以前的 XML 配置文件
public class AppConfig {

    @Bean  // 显式告诉 Spring：把这个方法返回的对象注册为 Bean
    public UserService userService() {
        return new UserService();
    }
}
```

##### 3. 原理

- `@Configuration` 表示这个类是一个配置类（类似以前的 XML `<beans>`）。
- `@Bean` 注解的方法，返回的对象会被 **显式加入 IoC 容器**。
- 即使 `UserService` 类本身没有 `@Component` 注解，也能被容器管理。

##### 4. 使用场景

什么时候需要用 **显式注册**呢？

1. 你无法在类上加 `@Component`（比如这是第三方库里的类，没法改源码）。

   ```
   @Bean
   public ObjectMapper objectMapper() {
       return new ObjectMapper();
   }
   ```

2. 你需要对 Bean 的创建过程做一些定制化处理。

   ```
   @Bean
   public DataSource dataSource() {
       HikariDataSource ds = new HikariDataSource();
       ds.setJdbcUrl("jdbc:mysql://localhost:3306/test");
       ds.setUsername("root");
       ds.setPassword("123456");
       return ds;
   }
   ```

3. 想给容器里注册多个不同配置的同类对象（用 `@Bean(name="xxx")` 区分）。















## 前端三剑客

#### HTML

##### 基础

![b653558a4706221f65ace40052e284ea](../Documents/Tencent Files/1759751014/nt_qq/nt_data/Pic/2025-07/Ori/b653558a4706221f65ace40052e284ea.jpg)

![ac5449bbad840350d73838c850d54834](../Documents/Tencent Files/1759751014/nt_qq/nt_data/Pic/2025-07/Ori/ac5449bbad840350d73838c850d54834.jpg)

![0562544f92c8cf30207aeab3c3a53215](../Documents/Tencent Files/1759751014/nt_qq/nt_data/Pic/2025-07/Ori/0562544f92c8cf30207aeab3c3a53215.jpg)

![9abbeeccfc9a230f996d9a9dfe6b0a5b](../Documents/Tencent Files/1759751014/nt_qq/nt_data/Pic/2025-07/Ori/9abbeeccfc9a230f996d9a9dfe6b0a5b.jpg)

##### 常见标签

![image-20250724232020331](../AppData/Roaming/Typora/typora-user-images/image-20250724232020331.png)

#### CSS

##### 常用方法

![image-20250724232504153](../AppData/Roaming/Typora/typora-user-images/image-20250724232504153.png)

![image-20250724232742884](../AppData/Roaming/Typora/typora-user-images/image-20250724232742884.png)

颜色表示

![image-20250724233319645](../AppData/Roaming/Typora/typora-user-images/image-20250724233319645.png)

##### CSS样式选择器

![image-20250725162659972](../AppData/Roaming/Typora/typora-user-images/image-20250725162659972.png)

![image-20250725163803570](../AppData/Roaming/Typora/typora-user-images/image-20250725163803570.png)

![image-20250725163033113](../AppData/Roaming/Typora/typora-user-images/image-20250725163033113.png)

优先级：ID选择器>类选择器>元素选择器

![image-20250725163103348](../AppData/Roaming/Typora/typora-user-images/image-20250725163103348.png)

![image-20250725163517924](../AppData/Roaming/Typora/typora-user-images/image-20250725163517924.png)

##### 一些解释

![image-20250725165132660](../AppData/Roaming/Typora/typora-user-images/image-20250725165132660.png)

相对路径

![image-20250725165810196](../AppData/Roaming/Typora/typora-user-images/image-20250725165810196.png)

##### 盒子模型

![image-20250725175216060](../AppData/Roaming/Typora/typora-user-images/image-20250725175216060.png)

![image-20250725180557217](../AppData/Roaming/Typora/typora-user-images/image-20250725180557217.png)

![image-20250725180938659](../AppData/Roaming/Typora/typora-user-images/image-20250725180938659.png)

![image-20250725181139183](../AppData/Roaming/Typora/typora-user-images/image-20250725181139183.png)

![image-20250725181701968](../AppData/Roaming/Typora/typora-user-images/image-20250725181701968.png)

![image-20250725191809629](../AppData/Roaming/Typora/typora-user-images/image-20250725191809629.png)

##### 表单

![image-20250725201716762](../AppData/Roaming/Typora/typora-user-images/image-20250725201716762.png)

![image-20250725202347056](../AppData/Roaming/Typora/typora-user-images/image-20250725202347056.png)

![image-20250725202621141](../AppData/Roaming/Typora/typora-user-images/image-20250725202621141.png)

#### JavaScript

##### 介绍

![image-20250725233405324](../AppData/Roaming/Typora/typora-user-images/image-20250725233405324.png)

![image-20250725233657501](../AppData/Roaming/Typora/typora-user-images/image-20250725233657501.png)

##### 使用

![image-20250725234005541](../AppData/Roaming/Typora/typora-user-images/image-20250725234005541.png)

##### 语法

![image-20250726142218329](../AppData/Roaming/Typora/typora-user-images/image-20250726142218329.png)

![image-20250726142537011](../AppData/Roaming/Typora/typora-user-images/image-20250726142537011.png)

数据类型

![image-20250726142912038](../AppData/Roaming/Typora/typora-user-images/image-20250726142912038.png)

![image-20250726143151181](../AppData/Roaming/Typora/typora-user-images/image-20250726143151181.png)

函数

![image-20250726173333837](../AppData/Roaming/Typora/typora-user-images/image-20250726173333837.png)

![image-20250726173707824](../AppData/Roaming/Typora/typora-user-images/image-20250726173707824.png)

自定义对象

![image-20250726174109039](../AppData/Roaming/Typora/typora-user-images/image-20250726174109039.png)

![image-20250726175804801](../AppData/Roaming/Typora/typora-user-images/image-20250726175804801.png)

DOM

![image-20250726182119862](../AppData/Roaming/Typora/typora-user-images/image-20250726182119862.png)

![image-20250726182342389](../AppData/Roaming/Typora/typora-user-images/image-20250726182342389.png)

![image-20250726182818479](../AppData/Roaming/Typora/typora-user-images/image-20250726182818479.png)

![image-20250726201751021](../AppData/Roaming/Typora/typora-user-images/image-20250726201751021.png)

![image-20250726202248002](../AppData/Roaming/Typora/typora-user-images/image-20250726202248002.png)

#### vue

##### 用法

![image-20250726214154370](../AppData/Roaming/Typora/typora-user-images/image-20250726214154370.png)

常用指令

![image-20250726215029464](../AppData/Roaming/Typora/typora-user-images/image-20250726215029464.png)

## Maven

#### 简介

![image-20250727153034968](../AppData/Roaming/Typora/typora-user-images/image-20250727153034968.png)

![image-20250727152855591](../AppData/Roaming/Typora/typora-user-images/image-20250727152855591.png)

#### 创建Maven项目

![image-20250727162716353](../AppData/Roaming/Typora/typora-user-images/image-20250727162716353.png)

#### xml简介

![image-20250727164907001](../AppData/Roaming/Typora/typora-user-images/image-20250727164907001.png)

![image-20250727164934927](../AppData/Roaming/Typora/typora-user-images/image-20250727164934927.png)



#### 导入项目

![image-20250727165754199](../AppData/Roaming/Typora/typora-user-images/image-20250727165754199.png)



![image-20250727165034951](../AppData/Roaming/Typora/typora-user-images/image-20250727165034951.png)

![image-20250727165348337](../AppData/Roaming/Typora/typora-user-images/image-20250727165348337.png)

将项目粘贴进去

![image-20250727165410052](../AppData/Roaming/Typora/typora-user-images/image-20250727165410052.png)









![image-20250727165130451](../AppData/Roaming/Typora/typora-user-images/image-20250727165130451.png)

![image-20250727165627286](../AppData/Roaming/Typora/typora-user-images/image-20250727165627286.png)

#### 依赖配置

![image-20250727170058629](../AppData/Roaming/Typora/typora-user-images/image-20250727170058629.png)

**官网：**https://mvnrepository.com/





排除依赖

![image-20250727215850441](../AppData/Roaming/Typora/typora-user-images/image-20250727215850441.png)

#### 生命周期

![image-20250727220202618](../AppData/Roaming/Typora/typora-user-images/image-20250727220202618.png)

关注这五个阶段

![image-20250727220303011](../AppData/Roaming/Typora/typora-user-images/image-20250727220303011.png)

![image-20250727220559918](../AppData/Roaming/Typora/typora-user-images/image-20250727220559918.png)

#### 测试

##### 简介

![image-20250727223616788](../AppData/Roaming/Typora/typora-user-images/image-20250727223616788.png)

![image-20250727223713786](../AppData/Roaming/Typora/typora-user-images/image-20250727223713786.png)

##### 单元测试

![image-20250727224038828](../AppData/Roaming/Typora/typora-user-images/image-20250727224038828.png)

![image-20250727232701892](../AppData/Roaming/Typora/typora-user-images/image-20250727232701892.png)

##### 断言

![image-20250727233819209](../AppData/Roaming/Typora/typora-user-images/image-20250727233819209.png)

![image-20250727233351593](../AppData/Roaming/Typora/typora-user-images/image-20250727233351593.png)

##### 常见注解

![image-20250727234244789](../AppData/Roaming/Typora/typora-user-images/image-20250727234244789.png)

![image-20250727235119694](../AppData/Roaming/Typora/typora-user-images/image-20250727235119694.png)

##### 企业测试

![image-20250727235527535](../AppData/Roaming/Typora/typora-user-images/image-20250727235527535.png)

![image-20250727235747255](../AppData/Roaming/Typora/typora-user-images/image-20250727235747255.png)

![image-20250728000038221](../AppData/Roaming/Typora/typora-user-images/image-20250728000038221.png)

##### 覆盖率

![image-20250728000356871](../AppData/Roaming/Typora/typora-user-images/image-20250728000356871.png)

##### 依赖范围

![image-20250728110931431](../AppData/Roaming/Typora/typora-user-images/image-20250728110931431.png)

跳过测试

![image-20250728111355754](../AppData/Roaming/Typora/typora-user-images/image-20250728111355754.png)

#### 常见问题及解决方法

下载的包不完整

![image-20250729104635205](../AppData/Roaming/Typora/typora-user-images/image-20250729104635205.png)

解决方法

![image-20250729104451382](../AppData/Roaming/Typora/typora-user-images/image-20250729104451382.png)

## SpringBoot Web

#### 入门

##### 常见问题及解决

![image-20250729164236472](../AppData/Roaming/Typora/typora-user-images/image-20250729164236472.png)

##### http协议介绍

![image-20250729165826524](../AppData/Roaming/Typora/typora-user-images/image-20250729165826524.png)



##### 请求数据（客户端对服务器端）

![image-20250729170657627](../AppData/Roaming/Typora/typora-user-images/image-20250729170657627.png)

![image-20250729170524303](../AppData/Roaming/Typora/typora-user-images/image-20250729170524303.png)

![image-20250729170449028](../AppData/Roaming/Typora/typora-user-images/image-20250729170449028.png)

![image-20250729171017178](../AppData/Roaming/Typora/typora-user-images/image-20250729171017178.png)

##### 获取请求（httpservletrequest）操作

我是服务器，第一个是要获取到我这个服务器内容的地址，第二个是我的完整地址

![image-20250729171644017](../AppData/Roaming/Typora/typora-user-images/image-20250729171644017.png)

##### 响应数据（服务器端对客户端）

![image-20250729180456381](../AppData/Roaming/Typora/typora-user-images/image-20250729180456381.png)

![image-20250729180607234](../AppData/Roaming/Typora/typora-user-images/image-20250729180607234.png)

![image-20250729180733399](../AppData/Roaming/Typora/typora-user-images/image-20250729180733399.png)

![image-20250729181015621](../AppData/Roaming/Typora/typora-user-images/image-20250729181015621.png)

响应数据设置

![image-20250729182242953](../AppData/Roaming/Typora/typora-user-images/image-20250729182242953.png)

代码实现

基于Servlet

![image-20250729182528654](../AppData/Roaming/Typora/typora-user-images/image-20250729182528654.png)

基于Spring实现

![image-20250729183124692](../AppData/Roaming/Typora/typora-user-images/image-20250729183124692.png)

#### 架构

##### 三层架构

![image-20250730162119706](../AppData/Roaming/Typora/typora-user-images/image-20250730162119706.png)

##### 内聚与耦合

###### 定义

![image-20250730183312243](../AppData/Roaming/Typora/typora-user-images/image-20250730183312243.png)

###### 解决方法

![image-20250730183646372](../AppData/Roaming/Typora/typora-user-images/image-20250730183646372.png)

解决方法

![image-20250730184216869](../AppData/Roaming/Typora/typora-user-images/image-20250730184216869.png)

![image-20250730184313454](../AppData/Roaming/Typora/typora-user-images/image-20250730184313454.png)

![image-20250730184417584](../AppData/Roaming/Typora/typora-user-images/image-20250730184417584.png)

###### IOC详解

![image-20250730184840413](../AppData/Roaming/Typora/typora-user-images/image-20250730184840413.png)

必须要扫描到，bean注解才会生效（扫描范围：启动类及其子包）

![image-20250730190919044](../AppData/Roaming/Typora/typora-user-images/image-20250730190919044.png)



###### DI详解

![image-20250730191705475](../AppData/Roaming/Typora/typora-user-images/image-20250730191705475.png)

![image-20250730210203595](../AppData/Roaming/Typora/typora-user-images/image-20250730210203595.png)



缺点：没有用setter或者getter封装

![image-20250730210357202](../AppData/Roaming/Typora/typora-user-images/image-20250730210357202.png)

![image-20250730210628228](../AppData/Roaming/Typora/typora-user-images/image-20250730210628228.png)

![image-20250730210733143](../AppData/Roaming/Typora/typora-user-images/image-20250730210733143.png)

###### 多个相同类型的bean出现的问题

![image-20250730211349140](../AppData/Roaming/Typora/typora-user-images/image-20250730211349140.png)

## MySQL

#### 如何启动

net start mysql

mysql -u root -p

输入密码

#### 简介

![image-20250730232835333](../AppData/Roaming/Typora/typora-user-images/image-20250730232835333.png)

#### 语言类型

##### 总的

![image-20250730233716342](../AppData/Roaming/Typora/typora-user-images/image-20250730233716342.png)

##### DDL及其语法

![image-20250730233916218](../AppData/Roaming/Typora/typora-user-images/image-20250730233916218.png)

###### 关于表

语法

![image-20250731181949509](../AppData/Roaming/Typora/typora-user-images/image-20250731181949509.png)

示例

![image-20250731182502955](../AppData/Roaming/Typora/typora-user-images/image-20250731182502955.png)

![image-20250731181844829](../AppData/Roaming/Typora/typora-user-images/image-20250731181844829.png)

数据类型

![image-20250731183208300](../AppData/Roaming/Typora/typora-user-images/image-20250731183208300.png)

![image-20250731183618039](../AppData/Roaming/Typora/typora-user-images/image-20250731183618039.png)

![image-20250731183740644](../AppData/Roaming/Typora/typora-user-images/image-20250731183740644.png)

###### 增删改查

![image-20250801210614496](../AppData/Roaming/Typora/typora-user-images/image-20250801210614496.png)

##### DML语句

###### 简介

![image-20250801211631619](../AppData/Roaming/Typora/typora-user-images/image-20250801211631619.png)

###### insert语句

![image-20250801211840459](../AppData/Roaming/Typora/typora-user-images/image-20250801211840459.png)

![image-20250801212650615](../AppData/Roaming/Typora/typora-user-images/image-20250801212650615.png)

###### update

![image-20250801215725062](../AppData/Roaming/Typora/typora-user-images/image-20250801215725062.png)

![image-20250801220017078](../AppData/Roaming/Typora/typora-user-images/image-20250801220017078.png)

###### delete

![image-20250801220049673](../AppData/Roaming/Typora/typora-user-images/image-20250801220049673.png)

![image-20250801220238855](../AppData/Roaming/Typora/typora-user-images/image-20250801220238855.png)

##### DQL语句

###### 简介

![image-20250801220327734](../AppData/Roaming/Typora/typora-user-images/image-20250801220327734.png)

![image-20250801220555528](../AppData/Roaming/Typora/typora-user-images/image-20250801220555528.png)

###### 基本查询

![image-20250801220714521](../AppData/Roaming/Typora/typora-user-images/image-20250801220714521.png)

![image-20250801221553182](../AppData/Roaming/Typora/typora-user-images/image-20250801221553182.png)

![image-20250801221716484](../AppData/Roaming/Typora/typora-user-images/image-20250801221716484.png)

###### 条件查询

![image-20250801233812015](../AppData/Roaming/Typora/typora-user-images/image-20250801233812015.png)

![image-20250801234833330](../AppData/Roaming/Typora/typora-user-images/image-20250801234833330.png)

###### 分组查询

![image-20250801235036083](../AppData/Roaming/Typora/typora-user-images/image-20250801235036083.png)

![image-20250801235307487](../AppData/Roaming/Typora/typora-user-images/image-20250801235307487.png)

优先使用

![image-20250801235358765](../AppData/Roaming/Typora/typora-user-images/image-20250801235358765.png)

![image-20250801235507088](../AppData/Roaming/Typora/typora-user-images/image-20250801235507088.png)

![image-20250801235623724](../AppData/Roaming/Typora/typora-user-images/image-20250801235623724.png)

![image-20250801235841692](../AppData/Roaming/Typora/typora-user-images/image-20250801235841692.png)

![image-20250802000139621](../AppData/Roaming/Typora/typora-user-images/image-20250802000139621.png)

![image-20250802000236520](../AppData/Roaming/Typora/typora-user-images/image-20250802000236520.png)

###### 排序查询

![image-20250802000500886](../AppData/Roaming/Typora/typora-user-images/image-20250802000500886.png)

![image-20250802000806025](../AppData/Roaming/Typora/typora-user-images/image-20250802000806025.png)

###### 分页查询

![image-20250802001016541](../AppData/Roaming/Typora/typora-user-images/image-20250802001016541.png)

![image-20250802001315432](../AppData/Roaming/Typora/typora-user-images/image-20250802001315432.png)

## Mybatis

#### 写在前面

这是操作数据库最底层的语言

![image-20250802185144043](../AppData/Roaming/Typora/typora-user-images/image-20250802185144043.png)

![image-20250802193212517](../AppData/Roaming/Typora/typora-user-images/image-20250802193212517.png)

![image-20250802193419294](../AppData/Roaming/Typora/typora-user-images/image-20250802193419294.png)

![image-20250802193535808](../AppData/Roaming/Typora/typora-user-images/image-20250802193535808.png)

![image-20250802200926157](../AppData/Roaming/Typora/typora-user-images/image-20250802200926157.png)

#### 简介

![image-20250802201359469](../AppData/Roaming/Typora/typora-user-images/image-20250802201359469.png)

#### 创建

![image-20250802204956106](../AppData/Roaming/Typora/typora-user-images/image-20250802204956106.png)

#### 操作

数据库连接操作

![image-20250802211034130](../AppData/Roaming/Typora/typora-user-images/image-20250802211034130.png)

![image-20250802210855090](../AppData/Roaming/Typora/typora-user-images/image-20250802210855090.png)

![image-20250802212132199](../AppData/Roaming/Typora/typora-user-images/image-20250802212132199.png)

![image-20250802232612465](../AppData/Roaming/Typora/typora-user-images/image-20250802232612465.png)

#### 连接等配置操作

![image-20250802224850354](../AppData/Roaming/Typora/typora-user-images/image-20250802224850354.png)

![image-20250802225217794](../AppData/Roaming/Typora/typora-user-images/image-20250802225217794.png)

![image-20250802225255375](../AppData/Roaming/Typora/typora-user-images/image-20250802225255375.png)

#### 对比

![image-20250802231857538](../AppData/Roaming/Typora/typora-user-images/image-20250802231857538.png)

#### 连接池

![image-20250802232336616](../AppData/Roaming/Typora/typora-user-images/image-20250802232336616.png)



![image-20250802232741952](../AppData/Roaming/Typora/typora-user-images/image-20250802232741952.png)

![image-20250802233037221](../AppData/Roaming/Typora/typora-user-images/image-20250802233037221.png)

#### 增删改查

##### 删除

![image-20250802233750234](../AppData/Roaming/Typora/typora-user-images/image-20250802233750234.png)

**![image-20250802234048814](../AppData/Roaming/Typora/typora-user-images/image-20250802234048814.png)**

![image-20250802234132453](../AppData/Roaming/Typora/typora-user-images/image-20250802234132453.png)



![image-20250802234302828](../AppData/Roaming/Typora/typora-user-images/image-20250802234302828.png)



![image-20250802234652026](../AppData/Roaming/Typora/typora-user-images/image-20250802234652026.png)

##### 增

![image-20250802235200093](../AppData/Roaming/Typora/typora-user-images/image-20250802235200093.png)

![image-20250802235407015](../AppData/Roaming/Typora/typora-user-images/image-20250802235407015.png)

![image-20250803000937832](../AppData/Roaming/Typora/typora-user-images/image-20250803000937832.png)



##### 改

![image-20250803001054625](../AppData/Roaming/Typora/typora-user-images/image-20250803001054625.png)



##### 查

传多个参数要取名字

![image-20250803001751157](../AppData/Roaming/Typora/typora-user-images/image-20250803001751157.png)

![image-20250803001935413](../AppData/Roaming/Typora/typora-user-images/image-20250803001935413.png)

![image-20250803002503571](../AppData/Roaming/Typora/typora-user-images/image-20250803002503571.png)



官方骨架

![image-20250803002154103](../AppData/Roaming/Typora/typora-user-images/image-20250803002154103.png)

![image-20250803002128857](../AppData/Roaming/Typora/typora-user-images/image-20250803002128857.png)

#### xml映射配置

##### 1.

![image-20250803164303389](../AppData/Roaming/Typora/typora-user-images/image-20250803164303389.png)



![image-20250803164529452](../AppData/Roaming/Typora/typora-user-images/image-20250803164529452.png)

![image-20250803164857758](../AppData/Roaming/Typora/typora-user-images/image-20250803164857758.png)

##### 2.

![image-20250803165608884](../AppData/Roaming/Typora/typora-user-images/image-20250803165608884.png)

#### SpringBoot项目配置文件

![image-20250803172414748](../AppData/Roaming/Typora/typora-user-images/image-20250803172414748.png)

![image-20250803173256060](../AppData/Roaming/Typora/typora-user-images/image-20250803173256060.png)

![image-20250803173546519](../AppData/Roaming/Typora/typora-user-images/image-20250803173546519.png)

![image-20250803173634428](../AppData/Roaming/Typora/typora-user-images/image-20250803173634428.png)



## 项目启动

![image-20250804204800702](../AppData/Roaming/Typora/typora-user-images/image-20250804204800702.png)

这是在切换文件

```
cd /d D:\CodingAPP\nginx-1.22.0-web
.\nginx.exe -t



nginx -s reload
```



这是在线网址https://heuqqdmbyk.feishu.cn/wiki/space/7413668442156498972?ccm_open_type=lark_wiki_spaceLink&open_tab_from=wiki_home

















## 软件开发



#### 准备工作

##### Restful

![image-20250803182001318](../AppData/Roaming/Typora/typora-user-images/image-20250803182001318.png)

![image-20250803182058905](../AppData/Roaming/Typora/typora-user-images/image-20250803182058905.png)

##### 项目创建

###### 开始

![image-20250902121038280](../AppData/Roaming/Typora/typora-user-images/image-20250902121038280.png)

![image-20250803191501755](../AppData/Roaming/Typora/typora-user-images/image-20250803191501755.png)



![image-20250803191530893](../AppData/Roaming/Typora/typora-user-images/image-20250803191530893.png)

###### 第二步

检查structure的sdk版本

![image-20250902121243216](../AppData/Roaming/Typora/typora-user-images/image-20250902121243216.png)

###### 检查Maven

![image-20250902121439070](../AppData/Roaming/Typora/typora-user-images/image-20250902121439070.png)

###### 修改编码

![image-20250902121531854](../AppData/Roaming/Typora/typora-user-images/image-20250902121531854.png)

###### 开始创建项目

![image-20250902121631182](../AppData/Roaming/Typora/typora-user-images/image-20250902121631182.png)

###### 勾选依赖

![image-20250902121731186](../AppData/Roaming/Typora/typora-user-images/image-20250902121731186.png)

![image-20250902121757576](../AppData/Roaming/Typora/typora-user-images/image-20250902121757576.png)

![image-20250902121817624](../AppData/Roaming/Typora/typora-user-images/image-20250902121817624.png)

![image-20250902121835883](../AppData/Roaming/Typora/typora-user-images/image-20250902121835883.png)

###### 创建成功

![image-20250902121919560](../AppData/Roaming/Typora/typora-user-images/image-20250902121919560.png)

###### 原来的删掉

![image-20250902122022026](../AppData/Roaming/Typora/typora-user-images/image-20250902122022026.png)

###### 加文件

![image-20250902122214295](../AppData/Roaming/Typora/typora-user-images/image-20250902122214295.png)

###### 创包

![image-20250902122310846](../AppData/Roaming/Typora/typora-user-images/image-20250902122310846.png)







##### 思维逻辑

![image-20250804004957629](../AppData/Roaming/Typora/typora-user-images/image-20250804004957629.png)

##### 未封装数据原因

![image-20250804170746121](../AppData/Roaming/Typora/typora-user-images/image-20250804170746121.png)

解决方法（两种）

![image-20250804172128925](../AppData/Roaming/Typora/typora-user-images/image-20250804172128925.png)

最终解决方法（输入camel出来）

![image-20250804172425225](../AppData/Roaming/Typora/typora-user-images/image-20250804172425225.png)

##### 反向代理

![image-20250804220848950](../AppData/Roaming/Typora/typora-user-images/image-20250804220848950.png)

![image-20250804221454038](../AppData/Roaming/Typora/typora-user-images/image-20250804221454038.png)

![image-20250804221613807](../AppData/Roaming/Typora/typora-user-images/image-20250804221613807.png)

#### 项目功能

##### 删除操作思维逻辑

![image-20250804222011946](../AppData/Roaming/Typora/typora-user-images/image-20250804222011946.png)

###### 方法一（不推荐）

![image-20250804222149147](../AppData/Roaming/Typora/typora-user-images/image-20250804222149147.png)

###### 方式二

![image-20250804222637659](../AppData/Roaming/Typora/typora-user-images/image-20250804222637659.png)

![image-20250804223553591](../AppData/Roaming/Typora/typora-user-images/image-20250804223553591.png)

###### 方式三

![image-20250804223840411](../AppData/Roaming/Typora/typora-user-images/image-20250804223840411.png)

![image-20250804223727103](../AppData/Roaming/Typora/typora-user-images/image-20250804223727103.png)

##### 新增功能

**注意这里的RequestBody**

![image-20250805003941429](../AppData/Roaming/Typora/typora-user-images/image-20250805003941429.png)

##### 修改操作

###### 思维逻辑

![image-20250805163341026](../AppData/Roaming/Typora/typora-user-images/image-20250805163341026.png)

###### 操作方法

![image-20250805165255372](../AppData/Roaming/Typora/typora-user-images/image-20250805165255372.png)

简略写法

![image-20250805165823889](../AppData/Roaming/Typora/typora-user-images/image-20250805165823889.png)

###### 改的思维逻辑

![image-20250805173449523](../AppData/Roaming/Typora/typora-user-images/image-20250805173449523.png)

@RequestBody将json封装在对象里

##### 抽象成公共部分

![image-20250805214831202](../AppData/Roaming/Typora/typora-user-images/image-20250805214831202.png)



#### 日志功能

##### 简介

![image-20250805215454136](../AppData/Roaming/Typora/typora-user-images/image-20250805215454136.png)

![image-20250805215738799](../AppData/Roaming/Typora/typora-user-images/image-20250805215738799.png)



##### 操作

![image-20250805220221064](../AppData/Roaming/Typora/typora-user-images/image-20250805220221064.png)



![image-20250805222030593](../AppData/Roaming/Typora/typora-user-images/image-20250805222030593.png)

##### 配置文件详解

![image-20250805222248296](../AppData/Roaming/Typora/typora-user-images/image-20250805222248296.png)

![image-20250805224832268](../AppData/Roaming/Typora/typora-user-images/image-20250805224832268.png)

日志记录的线程和他的级别

![image-20250805225153450](../AppData/Roaming/Typora/typora-user-images/image-20250805225153450.png)

![image-20250805230742210](../AppData/Roaming/Typora/typora-user-images/image-20250805230742210.png)

##### 日志级别

![image-20250805231245870](../AppData/Roaming/Typora/typora-user-images/image-20250805231245870.png)

#### 多表结构

##### 简介

![image-20250806172304840](../AppData/Roaming/Typora/typora-user-images/image-20250806172304840.png)

##### 一对多

![image-20250806172440651](../AppData/Roaming/Typora/typora-user-images/image-20250806172440651.png)

![image-20250806173136391](../AppData/Roaming/Typora/typora-user-images/image-20250806173136391.png)

###### 问题

![image-20250806175203640](../AppData/Roaming/Typora/typora-user-images/image-20250806175203640.png)

###### 解决办法（物理外键）

快捷方式

![image-20250806180956530](../AppData/Roaming/Typora/typora-user-images/image-20250806180956530.png)

![image-20250806181103949](../AppData/Roaming/Typora/typora-user-images/image-20250806181103949.png)



![image-20250806180115014](../AppData/Roaming/Typora/typora-user-images/image-20250806180115014.png)

###### 解决方法（逻辑外键）

![image-20250806181314842](../AppData/Roaming/Typora/typora-user-images/image-20250806181314842.png)

##### 一对一

![image-20250806183808398](../AppData/Roaming/Typora/typora-user-images/image-20250806183808398.png)

![image-20250806184034431](../AppData/Roaming/Typora/typora-user-images/image-20250806184034431.png)

##### 多对多

###### 方法

![image-20250806190412513](../AppData/Roaming/Typora/typora-user-images/image-20250806190412513.png)

##### 案例

后面的与前面的相关联（后指前）

![image-20250808115049044](../AppData/Roaming/Typora/typora-user-images/image-20250808115049044.png)

##### 多表查询

###### 出现的问题

![image-20250808120620689](../AppData/Roaming/Typora/typora-user-images/image-20250808120620689.png)

![image-20250808120449068](../AppData/Roaming/Typora/typora-user-images/image-20250808120449068.png)

###### 解决

![image-20250808120714830](../AppData/Roaming/Typora/typora-user-images/image-20250808120714830.png)

###### 多表查询分类

![image-20250808120844223](../AppData/Roaming/Typora/typora-user-images/image-20250808120844223.png)

###### 内连接

![image-20250808211741363](../AppData/Roaming/Typora/typora-user-images/image-20250808211741363.png)



###### 内连接注意事项

他是查询两个表的交集，第一：两个有外键，第二：关联的那个属性它的不为空，必须有值

![image-20250808121734628](../AppData/Roaming/Typora/typora-user-images/image-20250808121734628.png)

![image-20250808211628977](../AppData/Roaming/Typora/typora-user-images/image-20250808211628977.png)

###### 外连接

左右外连接

查谁就谁外连接

![image-20250808215353279](../AppData/Roaming/Typora/typora-user-images/image-20250808215353279.png)

###### 内外连接区别

内连接和外连接的主要区别在于它们如何处理没有匹配值的行。

- **内连接（INNER JOIN）**：**不能查询空的字段**。它只返回在两个（或多个）表中都存在匹配值的行。如果一个表的某行在另一个表中没有匹配，那么该行就不会出现在结果中，集中因此永远不会返回一个“空”的、不匹配的字段。
- **外连接（OUTER JOIN）**：**可以查询空的字段**。它会返回所有匹配项的行，同时染色体返回一个表中没有匹配值的行。对于那些没有匹配项的行，在外连接结果中，来自另一个表的列将显示为`NULL`（空值）。





###### 子查询

![image-20250808223234838](../AppData/Roaming/Typora/typora-user-images/image-20250808223234838.png)



![image-20250808232032896](../AppData/Roaming/Typora/typora-user-images/image-20250808232032896.png)

![image-20250808234835126](../AppData/Roaming/Typora/typora-user-images/image-20250808234835126.png)





###### 写在后面

![image-20250808235500272](../AppData/Roaming/Typora/typora-user-images/image-20250808235500272.png)

#### 分页查询

##### 简介方法

![image-20250810221343637](../AppData/Roaming/Typora/typora-user-images/image-20250810221343637.png)

![image-20250810221439363](../AppData/Roaming/Typora/typora-user-images/image-20250810221439363.png)

##### 思路

![image-20250811003408377](../AppData/Roaming/Typora/typora-user-images/image-20250811003408377.png)

##### PageHelper

###### 简介

![image-20250811142644189](../AppData/Roaming/Typora/typora-user-images/image-20250811142644189.png)

###### 必要条件

![image-20250811142828030](../AppData/Roaming/Typora/typora-user-images/image-20250811142828030.png)

###### 这里在进行类型转换

![image-20250811151335434](../AppData/Roaming/Typora/typora-user-images/image-20250811151335434.png)

图片中的代码 `Page<Emp> p = (Page<Emp>) empList;` 能够进行强转，是因为你使用了 MyBatis 分页插件 PageHelper。

当你在 `EmpServiceImpl.java` 中调用 `PageHelper.startPage(page, pageSize);` 后，MyBatis 分页插件会自动拦截接下来的第一个 MyBatis 查询请求，并对其进行动态 SQL 改造，例如：

1. **添加分页 SQL：** 它会在你原始的 SQL 语句后面自动追加 `limit` 子句，以实现物理分页。
2. **执行 count 查询：** 在执行你的查询之前，它会先执行一个额外的 `count` 查询来获取总记录数。
3. **返回 `Page` 对象：** 在执行完分页查询后，PageHelper 不再返回普通的 `java.util.ArrayList`，而是返回一个实现了 `java.util.List` 接口的 `com.github.pagehelper.Page` 对象。这个 `Page` 对象除了包含分页后的结果列表，还额外包含了总记录数、总页数等分页信息。

因此，`empMapper.list()` 返回的 `empList` 虽然声明的类型是 `List<Emp>`，但实际运行时的对象类型是 `Page<Emp>`。因为 `Page<Emp>` 是 `List<Emp>` 的一个子类，所以可以安全地进行强制类型转换。



    class Parent {}
    class Child extends Parent {}
    
    public class Test {
        public static void main(String[] args) {
            // 父类引用指向子类对象（向上转型，自动完成）
            Parent parent = new Child(); 
        // 强制转换为子类（合法，因为实际对象是 Child）
        Child child = (Child) parent; // 正确，无异常
    }
}

###### 注意事项

![image-20250811184724655](../AppData/Roaming/Typora/typora-user-images/image-20250811184724655.png)

注意日期格式

![image-20250811191109404](../AppData/Roaming/Typora/typora-user-images/image-20250811191109404.png)

配置select文件

![image-20250811192949960](../AppData/Roaming/Typora/typora-user-images/image-20250811192949960.png)



注意这里的拼接方式

![image-20250811220525395](../AppData/Roaming/Typora/typora-user-images/image-20250811220525395.png)

###### 优化

![image-20250811221001337](../AppData/Roaming/Typora/typora-user-images/image-20250811221001337.png)

![image-20250811222926386](../AppData/Roaming/Typora/typora-user-images/image-20250811222926386.png)



##### 新增员工

###### 思路

![image-20250812004603430](../AppData/Roaming/Typora/typora-user-images/image-20250812004603430.png)



###### 方法

![image-20250813171020397](../AppData/Roaming/Typora/typora-user-images/image-20250813171020397.png)

###### 主键返回

![image-20250813172231047](../AppData/Roaming/Typora/typora-user-images/image-20250813172231047.png)

![image-20250813183222420](../AppData/Roaming/Typora/typora-user-images/image-20250813183222420.png)

![image-20250813183746713](../AppData/Roaming/Typora/typora-user-images/image-20250813183746713.png)







#### 事务管理

##### 简介

![image-20250814182655589](../AppData/Roaming/Typora/typora-user-images/image-20250814182655589.png)

##### 操作

![image-20250814182757423](../AppData/Roaming/Typora/typora-user-images/image-20250814182757423.png)

##### SpringBoot操作

![image-20250814191245916](../AppData/Roaming/Typora/typora-user-images/image-20250814191245916.png)

##### 上面方法的不足以及解决方法

###### 不足

![image-20250814213021722](../AppData/Roaming/Typora/typora-user-images/image-20250814213021722.png)

###### 解决方法

![image-20250814215002316](../AppData/Roaming/Typora/typora-user-images/image-20250814215002316.png)

###### 事物进阶

![image-20250814215250342](../AppData/Roaming/Typora/typora-user-images/image-20250814215250342.png)

防止其他事务回滚才这么用

![image-20250814225604634](../AppData/Roaming/Typora/typora-user-images/image-20250814225604634.png)

![image-20250814230508620](../AppData/Roaming/Typora/typora-user-images/image-20250814230508620.png)

###### 事物的四大特性

![image-20250814230742924](../AppData/Roaming/Typora/typora-user-images/image-20250814230742924.png)

#### 文件上传

##### 简介

![image-20250815165132085](../AppData/Roaming/Typora/typora-user-images/image-20250815165132085.png)

![image-20250815165449998](../AppData/Roaming/Typora/typora-user-images/image-20250815165449998.png)

![image-20250815211913563](../AppData/Roaming/Typora/typora-user-images/image-20250815211913563.png)

![image-20250815212226336](../AppData/Roaming/Typora/typora-user-images/image-20250815212226336.png)

##### 阿里云OSS

![image-20250815220930993](../AppData/Roaming/Typora/typora-user-images/image-20250815220930993.png)

###### OSSclient

```java
import com.aliyun.oss.*;
import com.aliyun.oss.common.auth.*;
import com.aliyun.oss.common.comm.SignVersion;
import com.aliyun.oss.model.Bucket;

import java.util.List;

/**
 * OSS SDK 基础使用示例
 * 展示如何初始化 OSS 客户端并列出所有 Bucket
 */
public class Demo {

    public static void main(String[] args) throws Exception {
        // 创建 ClientBuilderConfiguration 实例，用于配置 OSS 客户端参数
        ClientBuilderConfiguration clientBuilderConfiguration = new ClientBuilderConfiguration();
        // 设置签名算法版本为 V4
        clientBuilderConfiguration.setSignatureVersion(SignVersion.V4);
        // 设置使用 HTTPS 协议访问 OSS，保证传输安全性
        clientBuilderConfiguration.setProtocol(Protocol.HTTPS);
        
        // 创建 OSS 客户端实例
        OSS ossClient = OSSClientBuilder.create()
                // 以华东1（杭州）地域的外网访问域名为例，Endpoint填写为oss-cn-hangzhou.aliyuncs.com
                .endpoint("oss-cn-hangzhou.aliyuncs.com")
                // 从环境变量中获取访问凭证（需提前配置 OSS_ACCESS_KEY_ID 和 OSS_ACCESS_KEY_SECRET）
                .credentialsProvider(CredentialsProviderFactory.newEnvironmentVariableCredentialsProvider())
                // 设置客户端配置
                .clientConfiguration(clientBuilderConfiguration)
                // 以华东1（杭州）地域为例，Region填写为cn-hangzhou
                .region("cn-hangzhou")
                .build();

        try {
            // 列出当前用户的所有 Bucket
            List<Bucket> buckets = ossClient.listBuckets();
            // 遍历打印每个 Bucket 的名称
            for (Bucket bucket : buckets) {
                System.out.println(bucket.getName());
            }
        } finally {
            // 当OSSClient实例不再使用时，调用shutdown方法以释放资源
            ossClient.shutdown();
        }
    }
}
```

**这个例子更好**

```
package com.it.utils;

import com.aliyun.oss.*;
import com.aliyun.oss.common.auth.CredentialsProviderFactory;
import com.aliyun.oss.common.auth.EnvironmentVariableCredentialsProvider;
import com.aliyun.oss.common.comm.SignVersion;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;
import java.io.ByteArrayInputStream;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.UUID;

@Component
public class AliyunOSSOperator {
    @Autowired
    AliyunOSSProperties aliyunOSSProperties;

//    @Value("${aliyun.oss.endpoint}")
//    private String endpoint;
//    @Value("${aliyun.oss.bucketName}")
//    private String bucketName;
//    @Value("${aliyun.oss.region}")
//    private String region;


    public String upload(byte[] content, String originalFilename) throws Exception {
        String endpoint = aliyunOSSProperties.getEndpoint();
        String bucketName = aliyunOSSProperties.getBucketName();
        String region = aliyunOSSProperties.getRegion();


        // 从环境变量中获取访问凭证。运行本代码示例之前，请确保已设置环境变量OSS_ACCESS_KEY_ID和OSS_ACCESS_KEY_SECRET。
        EnvironmentVariableCredentialsProvider credentialsProvider = CredentialsProviderFactory.newEnvironmentVariableCredentialsProvider();

        // 填写Object完整路径，例如202406/1.png。Object完整路径中不能包含Bucket名称。
        //获取当前系统日期的字符串,格式为 yyyy/MM
        String dir = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyy/MM"));
        //生成一个新的不重复的文件名
        String newFileName = UUID.randomUUID() + originalFilename.substring(originalFilename.lastIndexOf("."));
        String objectName = dir + "/" + newFileName;

        // 创建OSSClient实例。
        ClientBuilderConfiguration clientBuilderConfiguration = new ClientBuilderConfiguration();
        clientBuilderConfiguration.setSignatureVersion(SignVersion.V4);
        OSS ossClient = OSSClientBuilder.create()
                .endpoint(endpoint)
                .credentialsProvider(credentialsProvider)
                .clientConfiguration(clientBuilderConfiguration)
                .region(region)
                .build();

        try {
            ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(content));
        } finally {
            ossClient.shutdown();
        }

        return endpoint.split("//")[0] + "//" + bucketName + "." + endpoint.split("//")[1] + "/" + objectName;
    }

}
```



###### 存图片思路

![image-20250815234148028](../AppData/Roaming/Typora/typora-user-images/image-20250815234148028.png)

###### 存图片修改后代码

![image-20250815234948089](../AppData/Roaming/Typora/typora-user-images/image-20250815234948089.png)

修改名字

![image-20250816001406931](../AppData/Roaming/Typora/typora-user-images/image-20250816001406931.png)

###### 优化

两种方法

![image-20250816161546742](../AppData/Roaming/Typora/typora-user-images/image-20250816161546742.png)

![image-20250816160031819](../AppData/Roaming/Typora/typora-user-images/image-20250816160031819.png)

#### 删除员工

##### 目标

![image-20250816171401151](../AppData/Roaming/Typora/typora-user-images/image-20250816171401151.png)

##### 思路

![image-20250816171721177](../AppData/Roaming/Typora/typora-user-images/image-20250816171721177.png)

##### 方法

![image-20250816171900736](../AppData/Roaming/Typora/typora-user-images/image-20250816171900736.png)

#### 修改员工

##### 回显思路

![image-20250816231104798](../AppData/Roaming/Typora/typora-user-images/image-20250816231104798.png)

##### 回显注意

![image-20250816235406552](../AppData/Roaming/Typora/typora-user-images/image-20250816235406552.png)

![image-20250816235239776](../AppData/Roaming/Typora/typora-user-images/image-20250816235239776.png)

##### 修改思路（先删后存）

![image-20250817003126984](../AppData/Roaming/Typora/typora-user-images/image-20250817003126984.png)

#### 统计员工

##### sql语句

**注意这里的case语句，有两种方法**

![image-20250818113235768](../AppData/Roaming/Typora/typora-user-images/image-20250818113235768.png)

![image-20250818113506094](../AppData/Roaming/Typora/typora-user-images/image-20250818113506094.png)

##### 思路

![image-20250818113725019](../AppData/Roaming/Typora/typora-user-images/image-20250818113725019.png)

##### 重点函数

![image-20250818140909659](../AppData/Roaming/Typora/typora-user-images/image-20250818140909659.png)

```
List<Object> joblist = list.stream().map(dataMap -> dataMap.get("pos")).toList();
```

- `list.stream()`: 这行代码将 `list`（假设它是一个 `List<Map<String, Object>>` 类型的对象，其中每个 `Map` 代表一行数据，包含键值对，例如 `{"pos": "学工部", "num": 10}`）转换为一个 `Stream`。`Stream` 提供了一种函数式编程的方式来处理集合。
- `.map(dataMap -> dataMap.get("pos"))`: 这是对流中的每个元素进行操作。`map` 方法接受一个函数，并将其应用于流中的每个元素，然后返回一个新的流。
  - `dataMap -> dataMap.get("pos")`: 这是一个 Lambda 表达式。它表示对于流中的每一个元素 `dataMap`（即列表中的每一个 `Map`），执行 `dataMap.get("pos")` 操作。这会从每个 `Map` 中获取键为 `"pos"` 对应的值。
- `.toList()`: 这是 Java 16 引入的便捷方法，用于将流中的所有元素收集到一个新的 `List` 中。
- **总体来说**：这行代码遍历了 `list` 中的所有元素（`Map`），从每个 `Map` 中提取 `"pos"` 键对应的值，并将这些值收集成一个新的 `List`，赋值给 `joblist` 变量。`joblist` 将包含所有的“部门名称”（例如：`["学工部", "教研部", "咨询部", ...]`）。

##### mysql的if函数

![image-20250818145940614](../AppData/Roaming/Typora/typora-user-images/image-20250818145940614.png)

#### 登录

##### 思路

![image-20250819215247719](../AppData/Roaming/Typora/typora-user-images/image-20250819215247719.png)

![image-20250819215842807](../AppData/Roaming/Typora/typora-user-images/image-20250819215842807.png)

##### 登录校验思路

![image-20250819225450883](../AppData/Roaming/Typora/typora-user-images/image-20250819225450883.png)

##### 会话技术

![image-20250819230410098](../AppData/Roaming/Typora/typora-user-images/image-20250819230410098.png)

###### 基于cookie

**服务器端创建cookie，又将cookie值传给网页，此后每次传信息都会把cookie传给服务端**

![image-20250819233320263](../AppData/Roaming/Typora/typora-user-images/image-20250819233320263.png)

![image-20250819231534404](../AppData/Roaming/Typora/typora-user-images/image-20250819231534404.png)

###### 基于session

![image-20250820172339035](../AppData/Roaming/Typora/typora-user-images/image-20250820172339035.png)

###### 令牌方案

![image-20250820172729533](../AppData/Roaming/Typora/typora-user-images/image-20250820172729533.png)



##### 令牌实现

###### JWT令牌简介

![image-20250820175059556](../AppData/Roaming/Typora/typora-user-images/image-20250820175059556.png)

###### JWT令牌生成，代码如下

![image-20250904204652175](../AppData/Roaming/Typora/typora-user-images/image-20250904204652175.png)

![image-20250820175204975](../AppData/Roaming/Typora/typora-user-images/image-20250820175204975.png)

![image-20250820180837812](../AppData/Roaming/Typora/typora-user-images/image-20250820180837812.png)

**解析**

![image-20250820193143678](../AppData/Roaming/Typora/typora-user-images/image-20250820193143678.png)

![image-20250820193451006](../AppData/Roaming/Typora/typora-user-images/image-20250820193451006.png)

##### 过滤器

![image-20250820210501340](../AppData/Roaming/Typora/typora-user-images/image-20250820210501340.png)

###### **代码实现及其重点**

![image-20250820211930858](../AppData/Roaming/Typora/typora-user-images/image-20250820211930858.png)

![image-20250820212229783](../AppData/Roaming/Typora/typora-user-images/image-20250820212229783.png)

**释放拦截操作**

![image-20250820213751006](../AppData/Roaming/Typora/typora-user-images/image-20250820213751006.png)

###### 重点

![image-20250820221746357](../AppData/Roaming/Typora/typora-user-images/image-20250820221746357.png)

###### filter执行流程

![image-20250821002110117](../AppData/Roaming/Typora/typora-user-images/image-20250821002110117.png)

###### filter拦截

![image-20250821002606963](../AppData/Roaming/Typora/typora-user-images/image-20250821002606963.png)

###### 过滤器链

![image-20250821002846065](../AppData/Roaming/Typora/typora-user-images/image-20250821002846065.png)

##### 拦截器

###### 简介

![image-20250822111923789](../AppData/Roaming/Typora/typora-user-images/image-20250822111923789.png)

**目标资源方法通常是控制器Controller**

###### 令牌拦截器思路

![image-20250822113625616](../AppData/Roaming/Typora/typora-user-images/image-20250822113625616.png)

###### 注意和优化

![image-20250822142051112](../AppData/Roaming/Typora/typora-user-images/image-20250822142051112.png)

**执行流程**

![image-20250822142851289](../AppData/Roaming/Typora/typora-user-images/image-20250822142851289.png)



## Spring AOP

##### 简介

![image-20250822152300042](../AppData/Roaming/Typora/typora-user-images/image-20250822152300042.png)

##### 特有方法

joinPoint.getTarget()获取**目标对象（Target Object）**，也就是被代理的原始对象。

joinPoint.getSignature()当你需要获取方法的名称、参数类型、返回值类型等信息时。







##### 操作方法

###### 简介

![image-20250822152824863](../AppData/Roaming/Typora/typora-user-images/image-20250822152824863.png)

###### 实操

**注意上面的两个@**

**注意Around*()该包下所有类 *()该类下所有函数 *(..)无论是否有参数**

**getSignature是获取方法名**

![image-20250822155334249](../AppData/Roaming/Typora/typora-user-images/image-20250822155334249.png)

###### 核心概念

![image-20250822190040807](../AppData/Roaming/Typora/typora-user-images/image-20250822190040807.png)

###### 很重要

实在不行再收集资料理解

![image-20250822190642272](../AppData/Roaming/Typora/typora-user-images/image-20250822190642272.png)

**就是先进入下图(Controller)，注意此时的deptService是他对应的代理对象，然后又进入到下二proceed方法，接着进入下三，执行后再回下二**

![image-20250822195653155](../AppData/Roaming/Typora/typora-user-images/image-20250822195653155.png)

![image-20250822200153836](../AppData/Roaming/Typora/typora-user-images/image-20250822200153836.png)

![image-20250822200340073](../AppData/Roaming/Typora/typora-user-images/image-20250822200340073.png)

##### 通知类型

###### 简介

![image-20250822210415524](../AppData/Roaming/Typora/typora-user-images/image-20250822210415524.png)

###### 例子

![image-20250822211036632](../AppData/Roaming/Typora/typora-user-images/image-20250822211036632.png)

**这个是前面，这个是后面，千万注意别理解错了**

![image-20250822211352993](../AppData/Roaming/Typora/typora-user-images/image-20250822211352993.png)

###### 简便方法

![image-20250822211715585](../AppData/Roaming/Typora/typora-user-images/image-20250822211715585.png)

##### 通知顺序

###### 顺序

**注意：是类的类名的字母顺序**

![image-20250822213248357](../AppData/Roaming/Typora/typora-user-images/image-20250822213248357.png)

##### 切入点表达式

###### 简介（两种）

![image-20250822234710564](../AppData/Roaming/Typora/typora-user-images/image-20250822234710564.png)



###### 第一种的语法规则（推荐）

**打箭头的地方最好不要省略**

![image-20250822235221351](../AppData/Roaming/Typora/typora-user-images/image-20250822235221351.png)

![image-20250822235823069](../AppData/Roaming/Typora/typora-user-images/image-20250822235823069.png)



![image-20250823001615082](../AppData/Roaming/Typora/typora-user-images/image-20250823001615082.png)

只有这两个位置才能用..

![image-20250823001801576](../AppData/Roaming/Typora/typora-user-images/image-20250823001801576.png)



###### 方法二

![image-20250823002042300](../AppData/Roaming/Typora/typora-user-images/image-20250823002042300.png)

1. `@Target(ElementType.METHOD)`



这个注解指定了 `@Log` 注解可以用于哪些 Java 元素上。

- **`ElementType.METHOD`** 表示你的 `@Log` 注解只能用于**方法**上。

这意味着如果你尝试将 `@Log` 注解放在一个类、一个字段或一个参数上，编译器会报错。



2. `@Retention(RetentionPolicy.RUNTIME)`



这个注解指定了 `@Log` 注解的生命周期，也就是它在什么时候有效。

- **`RetentionPolicy.RUNTIME`** 表示 `@Log` 注解在**运行时**仍然可用。





如下方法（两张图都要）

![image-20250823002241134](../AppData/Roaming/Typora/typora-user-images/image-20250823002241134.png)

![image-20250823002331236](../AppData/Roaming/Typora/typora-user-images/image-20250823002331236.png)

##### 连接点

###### 简介

![image-20250823004450541](../AppData/Roaming/Typora/typora-user-images/image-20250823004450541.png)

###### 操作方法

![image-20250823004829164](../AppData/Roaming/Typora/typora-user-images/image-20250823004829164.png)



##### 如何传值给AOP程序

###### 利用ThreadLocal

![image-20250823151921869](../AppData/Roaming/Typora/typora-user-images/image-20250823151921869.png)

###### 思路

![image-20250823152739020](../AppData/Roaming/Typora/typora-user-images/image-20250823152739020.png)



![image-20250823154700871](../AppData/Roaming/Typora/typora-user-images/image-20250823154700871.png)

###### 代码

注意static和final

![image-20250823155048057](../AppData/Roaming/Typora/typora-user-images/image-20250823155048057.png)

## SpringBoot原理

#### 重要

##### 1.两个注解

```
@Target({ElementType.TYPE})` `@Retention(RetentionPolicy.RUNTIME)
```

这两个注解一起使用，表示你正在定义一个自定义注解，这个注解：

1. **只能用于类、接口、枚举或注解**（`@Target({ElementType.TYPE})`）。
2. **在运行时仍然有效**，可以通过反射机制进行访问（`@Retention(RetentionPolicy.RUNTIME)`）。



##### 2.Controller和IOC容器的关系

Controller 和 IoC 容器的关系可以总结为以下几点：

**由 IoC 容器创建和管理 Controller 对象**： 当你启动 Spring 应用时，IoC 容器会扫描你的代码。一旦发现被 `@Controller` 注解的类，它就会自动创建一个该类的实例，并将其放入容器中进行管理。你不再需要自己 `new Controller()`。

**由 IoC 容器为 Controller 注入依赖**： Controller 经常需要依赖其他服务来完成工作，比如一个 `UserService` 或 `OrderService`。你只需要在 Controller 类中用 `@Autowired` 注解这些服务，IoC 容器就会自动找到对应的实例，并注入到你的 Controller 中。这种依赖注入（Dependency Injection，DI）是 IoC 思想的具体实现。





##### 3.@EnableConfigurationProperties

**`@EnableConfigurationProperties(AliyunOSSProperties.class)`**是 Spring Boot 中一个非常常用的注解，它主要有两个作用：

1. **激活配置类：** 这个注解告诉 Spring Boot 框架，去**启用**并**加载**括号里指定的配置类（`AliyunOSSProperties.class`）。这意味着 Spring Boot 会处理这个类上的 `@ConfigurationProperties` 注解。
2. **注册为 Spring Bean：** 一旦这个配置类被启用，Spring Boot 就会自动创建 `AliyunOSSProperties` 类的一个实例，并将其作为 **Spring Bean** 注册到 **IoC 容器**中。





#### SpringBoot配置优先级

##### 配置文件

###### 第一种方法

优先级如下：

![image-20250823212151294](../AppData/Roaming/Typora/typora-user-images/image-20250823212151294.png)

###### 第二种方法

![image-20250823212530246](../AppData/Roaming/Typora/typora-user-images/image-20250823212530246.png)

![image-20250823213252494](../AppData/Roaming/Typora/typora-user-images/image-20250823213252494.png)

流程：

![image-20250823212631922](../AppData/Roaming/Typora/typora-user-images/image-20250823212631922.png)

![image-20250823212748111](../AppData/Roaming/Typora/typora-user-images/image-20250823212748111.png)

打包成jar包，并在命令行窗口运行快捷键(sp+ tab直接出项目名字)

双击package

![image-20250823213752090](../AppData/Roaming/Typora/typora-user-images/image-20250823213752090.png)

![image-20250823213851253](../AppData/Roaming/Typora/typora-user-images/image-20250823213851253.png)







###### 总的优先级

命令行参数>java系统属性>properties>yml>yaml

#### Bean管理

##### Bean的作用域

###### 简介

箭头是如何设置作用域

![image-20250823220426917](../AppData/Roaming/Typora/typora-user-images/image-20250823220426917.png)

![image-20250823225836069](../AppData/Roaming/Typora/typora-user-images/image-20250823225836069.png)

###### 默认的Bean是单例模式

![image-20250823222443107](../AppData/Roaming/Typora/typora-user-images/image-20250823222443107.png)

###### 如何选择Bean的作用域

多例的Bean是多个线程保存各个线程信息时选择

![image-20250823230405611](../AppData/Roaming/Typora/typora-user-images/image-20250823230405611.png)

![image-20250823230753466](../AppData/Roaming/Typora/typora-user-images/image-20250823230753466.png)

##### 第三方的Bean

###### 怎么做

![image-20250823232134636](../AppData/Roaming/Typora/typora-user-images/image-20250823232134636.png)

![image-20250823231257041](../AppData/Roaming/Typora/typora-user-images/image-20250823231257041.png)

![image-20250823231311380](../AppData/Roaming/Typora/typora-user-images/image-20250823231311380.png)

###### 代码演示



**相当于  AliyunOSSOperator这个类是你用的jar包下的类  你无法手动给其添加注解交给IOC容器管理  这样可以交给IOC容器管理**

必须要有下面这个箭头Bean

![image-20250823232322860](../AppData/Roaming/Typora/typora-user-images/image-20250823232322860.png)

![image-20250823232404113](../AppData/Roaming/Typora/typora-user-images/image-20250823232404113.png)

注意这里的箭头

![image-20250824005111963](../AppData/Roaming/Typora/typora-user-images/image-20250824005111963.png)

#### SpringBoot原理

##### 配置类

###### **配置类的核心作用**



1. **定义Bean** 配置类设置的作用是使用**`@Bean`**注解来定义Bean。被`@Bean`注解的方法，其返回值会被Spring IoC容器注册为一个Bean。

   **译文：**

   Java

   ```
   @Configuration
   public class AppConfig {
   
       @Bean
       public MyService myService() {
           // 创建并返回 MyService 实例
           return new MyServiceImpl();
       }
   
       @Bean
       public MyRepository myRepository() {
           // 创建并返回 MyRepository 实例
           return new MyRepositoryImpl();
       }
   }
   ```

   在这个例子中，方法返回的对象都会成为 Spring 容器中的 Bean，可以被组件其他注入和使用`myService`。`myRepository`

2. **管理Bean之间的依赖** 你可以在一个`@Bean`方法中调用另一个`@Bean`方法，来实现Bean之间的依赖注入。

   **译文：**

   Java

   ```
   @Configuration
   public class ServiceConfig {
   
       @Bean
       public UserService userService() {
           // 在这里调用另一个 @Bean 方法来获取依赖
           return new UserServiceImpl(userRepository());
       }
   
       @Bean
       public UserRepository userRepository() {
           return new UserRepositoryImpl();
       }
   }
   ```

   Spring会确保`userRepository()`方法只被调用一次，并将其作为单例Bean注入到`userService`中。

3. **集成第三方库** 配置类可以用于配置和集成非Spring的第三方库。例如，您可以定义一个数据源（DataSource）Bean，或者一个用于连接数据库的`JdbcTemplate`Bean。

------



###### **配置类及其`@Component`区别**



- **`@Configuration`**：专用于定义**`@Bean`**方法来创建和配置Bean。它通常用于**工厂模式**，即一个类专门用于创建其他类的实例。
- **`@Component`**( `@Service`, `@Repository`, `@Controller`)：用于标记一个类本身就是一个Bean。Spring会自动扫描这些类并将其注册为Bean。它们通常用于**声明一个业务组件**。

你可以把`@Configuration`想象成一个**工厂**，然后把`@Component`一个**产品**分类。

在 Spring Boot 中，配置类是构建和组织应用配置程序配置的核心，它使得配置更加清晰、可维护，并与 Java 代码紧密集成，是 Spring Boot 推荐的配置方式。





##### 核心

**Spring Boot提供的**

![image-20250824001935967](../AppData/Roaming/Typora/typora-user-images/image-20250824001935967.png)

##### **起步依赖原理**

![image-20250824002212304](../AppData/Roaming/Typora/typora-user-images/image-20250824002212304.png)

##### 自动配置原理

###### 什么是自动配置

**这些都不是自己定义了的对象，是系统自己注入的**

![image-20250824002501060](../AppData/Roaming/Typora/typora-user-images/image-20250824002501060.png)

###### 重要的为什么

![image-20250824011208857](../AppData/Roaming/Typora/typora-user-images/image-20250824011208857.png)

###### 代码演示一（不推荐）

**只有Component，不能注入**

![image-20250824005705716](../AppData/Roaming/Typora/typora-user-images/image-20250824005705716.png)

注意这里的箭头指定的是**只能**扫描的地方

![image-20250824004955974](../AppData/Roaming/Typora/typora-user-images/image-20250824004955974.png)

![image-20250824005432222](../AppData/Roaming/Typora/typora-user-images/image-20250824005432222.png)

###### 方法二（推荐）

![image-20250824005932810](../AppData/Roaming/Typora/typora-user-images/image-20250824005932810.png)

普通类

![image-20250824011413449](../AppData/Roaming/Typora/typora-user-images/image-20250824011413449.png)

![image-20250824010101309](../AppData/Roaming/Typora/typora-user-images/image-20250824010101309.png)

导入配置类

![image-20250824010148779](../AppData/Roaming/Typora/typora-user-images/image-20250824010148779.png)

![image-20250824010236712](../AppData/Roaming/Typora/typora-user-images/image-20250824010236712.png)

批量导入

![image-20250824010538784](../AppData/Roaming/Typora/typora-user-images/image-20250824010538784.png)

![image-20250824011541522](../AppData/Roaming/Typora/typora-user-images/image-20250824011541522.png)



最后最推荐

**这是做这个jar包的人自己做的，加上2图的箭头就行**

![image-20250824010745229](../AppData/Roaming/Typora/typora-user-images/image-20250824010745229.png)

![image-20250824010907966](../AppData/Roaming/Typora/typora-user-images/image-20250824010907966.png)

##### 自动配置原理源代码

###### 启动类本质是配置类

**下面是为什么能自动注入原理（因为有150几个配置类会自动注入现阶段项目所需的）**

![image-20250824115732313](../AppData/Roaming/Typora/typora-user-images/image-20250824115732313.png)

![image-20250824120157867](../AppData/Roaming/Typora/typora-user-images/image-20250824120157867.png)

符合条件才自动注入

![image-20250824120307981](../AppData/Roaming/Typora/typora-user-images/image-20250824120307981.png)

##### Conditional注解

###### 简介

![image-20250824132640140](../AppData/Roaming/Typora/typora-user-images/image-20250824132640140.png)

###### 三个演示

![image-20250824132845857](../AppData/Roaming/Typora/typora-user-images/image-20250824132845857.png)

![image-20250824133508175](../AppData/Roaming/Typora/typora-user-images/image-20250824133508175.png)

###### 总结

![image-20250824133736107](../AppData/Roaming/Typora/typora-user-images/image-20250824133736107.png)

![image-20250824133903618](../AppData/Roaming/Typora/typora-user-images/image-20250824133903618.png)

##### 自定义starter

###### 简介

![image-20250824202907342](../AppData/Roaming/Typora/typora-user-images/image-20250824202907342.png)

###### 操作顺序

![image-20250824203330759](../AppData/Roaming/Typora/typora-user-images/image-20250824203330759.png)

## Maven高级

#### 重要

##### 1.注意打包文件时

**直接打包是不行的，要先把拆分出来的模块在右侧下载**

![image-20250825151611490](../AppData/Roaming/Typora/typora-user-images/image-20250825151611490.png)

#### 分模块设计与开发

##### 简介

![image-20250825001519666](../AppData/Roaming/Typora/typora-user-images/image-20250825001519666.png)

##### 拆分策略

![image-20250825001710185](../AppData/Roaming/Typora/typora-user-images/image-20250825001710185.png)

##### 示例

就是把下面模块的一些东西放进另一个模块

![image-20250825003151297](../AppData/Roaming/Typora/typora-user-images/image-20250825003151297.png)

创建方法

![image-20250825003301949](../AppData/Roaming/Typora/typora-user-images/image-20250825003301949.png)

注意

![image-20250825003343427](../AppData/Roaming/Typora/typora-user-images/image-20250825003343427.png)

#### 继承

##### 以下几个方法可以一起用

##### 概念

![image-20250825110644474](../AppData/Roaming/Typora/typora-user-images/image-20250825110644474.png)

##### 如何操作

![image-20250825111459011](../AppData/Roaming/Typora/typora-user-images/image-20250825111459011.png)

![image-20250825111542381](../AppData/Roaming/Typora/typora-user-images/image-20250825111542381.png)

![image-20250825112652988](../AppData/Roaming/Typora/typora-user-images/image-20250825112652988.png)

![image-20250825115042825](../AppData/Roaming/Typora/typora-user-images/image-20250825115042825.png)

##### 版本锁定

**注意这里的标签是dependencyManagement**

![image-20250825115902374](../AppData/Roaming/Typora/typora-user-images/image-20250825115902374.png)

##### 更方便的调整版本

![image-20250825121040037](../AppData/Roaming/Typora/typora-user-images/image-20250825121040037.png)

![image-20250825121408837](../AppData/Roaming/Typora/typora-user-images/image-20250825121408837.png)

![image-20250825121815039](../AppData/Roaming/Typora/typora-user-images/image-20250825121815039.png)

#### 聚合

##### 简介

![image-20250825151922386](../AppData/Roaming/Typora/typora-user-images/image-20250825151922386.png)

##### 操作

![image-20250825152114471](../AppData/Roaming/Typora/typora-user-images/image-20250825152114471.png)

#### 继承与聚合

![image-20250825152530639](../AppData/Roaming/Typora/typora-user-images/image-20250825152530639.png)

#### 私服

##### 简介

![image-20250825153551153](../AppData/Roaming/Typora/typora-user-images/image-20250825153551153.png)

![image-20250825153859992](../AppData/Roaming/Typora/typora-user-images/image-20250825153859992.png)

##### 操作

###### 上传

![image-20250825154034862](../AppData/Roaming/Typora/typora-user-images/image-20250825154034862.png)

###### 下载

![image-20250825154200441](../AppData/Roaming/Typora/typora-user-images/image-20250825154200441.png)

![image-20250825154252454](../AppData/Roaming/Typora/typora-user-images/image-20250825154252454.png)



## 部署

### Linux

#### 操作系统简介

![image-20250825161359829](../AppData/Roaming/Typora/typora-user-images/image-20250825161359829.png)

#### Linux各种目录

![image-20250826115002120](../AppData/Roaming/Typora/typora-user-images/image-20250826115002120.png)

![image-20250826115346954](../AppData/Roaming/Typora/typora-user-images/image-20250826115346954.png)



#### 指令

Linux不能看文件后缀名，要看前面-d确定

![image-20250826115715053](../AppData/Roaming/Typora/typora-user-images/image-20250826115715053.png)

##### 目录文件指令

###### ls

看有没有指定目录，没有就默认当前目录

![image-20250826120035063](../AppData/Roaming/Typora/typora-user-images/image-20250826120035063.png)



-表示文件，d表示目录

![image-20250826120356546](../AppData/Roaming/Typora/typora-user-images/image-20250826120356546.png)

###### cd

![image-20250826141357987](../AppData/Roaming/Typora/typora-user-images/image-20250826141357987.png)

###### mkdir

![image-20250826142027201](../AppData/Roaming/Typora/typora-user-images/image-20250826142027201.png)

这个命令会**在当前所在的目录下**创建一个名为**itcast**的文件夹，然后在**itcast**文件夹里再创建一个名为**test**的文件夹。

###### rm

![image-20250826142805234](../AppData/Roaming/Typora/typora-user-images/image-20250826142805234.png)

###### cat

![image-20250826172933274](../AppData/Roaming/Typora/typora-user-images/image-20250826172933274.png)

###### more

![image-20250826173237381](../AppData/Roaming/Typora/typora-user-images/image-20250826173237381.png)

###### head

![image-20250826173526881](../AppData/Roaming/Typora/typora-user-images/image-20250826173526881.png)

###### tail

![image-20250826174241689](../AppData/Roaming/Typora/typora-user-images/image-20250826174241689.png)

##### 拷贝移动命令

###### cp

![image-20250826181806779](../AppData/Roaming/Typora/typora-user-images/image-20250826181806779.png)

![image-20250826182056238](../AppData/Roaming/Typora/typora-user-images/image-20250826182056238.png)

###### mv

第二个参数是以存在目录才执行移动

![image-20250826184712649](../AppData/Roaming/Typora/typora-user-images/image-20250826184712649.png)

##### 打包解包操作

###### tar

**打包和压缩要加上files**

![image-20250826212744645](../AppData/Roaming/Typora/typora-user-images/image-20250826212744645.png)

![image-20250826215519764](../AppData/Roaming/Typora/typora-user-images/image-20250826215519764.png)

##### 文本编辑命令

###### vim



![image-20250826225316032](../AppData/Roaming/Typora/typora-user-images/image-20250826225316032.png)

![image-20250826225918606](../AppData/Roaming/Typora/typora-user-images/image-20250826225918606.png)

###### find

![image-20250826233356650](../AppData/Roaming/Typora/typora-user-images/image-20250826233356650.png)

###### grep

![image-20250826234356605](../AppData/Roaming/Typora/typora-user-images/image-20250826234356605.png)

##### mysql

启动指令

![image-20250827115200745](../AppData/Roaming/Typora/typora-user-images/image-20250827115200745.png)

![image-20250827115253342](../AppData/Roaming/Typora/typora-user-images/image-20250827115253342.png)

![image-20250827120140640](../AppData/Roaming/Typora/typora-user-images/image-20250827120140640.png)

### Linux部署

##### 前端操作

**端口密码**

3306   root  1234

**localhost那里不确定，反正要填后端服务器地址**

![image-20250827134835234](../AppData/Roaming/Typora/typora-user-images/image-20250827134835234.png)

重新加载    停止服务

![image-20250827135712518](../AppData/Roaming/Typora/typora-user-images/image-20250827135712518.png)

![image-20250827135812569](../AppData/Roaming/Typora/typora-user-images/image-20250827135812569.png)

##### 后端操作

![image-20250827234108505](../AppData/Roaming/Typora/typora-user-images/image-20250827234108505.png)

![image-20250827135947290](../AppData/Roaming/Typora/typora-user-images/image-20250827135947290.png)

![image-20250827144245605](../AppData/Roaming/Typora/typora-user-images/image-20250827144245605.png)

![image-20250827145354416](../AppData/Roaming/Typora/typora-user-images/image-20250827145354416.png)



### docker部署

#### 简介

![image-20250827222304877](../AppData/Roaming/Typora/typora-user-images/image-20250827222304877.png)

![image-20250827222242660](../AppData/Roaming/Typora/typora-user-images/image-20250827222242660.png)

#### docker语法

下面是docker  mysql的端口密码

![image-20250827223849190](../AppData/Roaming/Typora/typora-user-images/image-20250827223849190.png)



![image-20250827223246923](../AppData/Roaming/Typora/typora-user-images/image-20250827223246923.png)

![image-20250827223504408](../AppData/Roaming/Typora/typora-user-images/image-20250827223504408.png)

![image-20250827223603350](../AppData/Roaming/Typora/typora-user-images/image-20250827223603350.png)

#### docker常见命令

##### 简介

![image-20250827231712010](../AppData/Roaming/Typora/typora-user-images/image-20250827231712010.png)

#### 数据卷

##### 简介

数据卷是虚拟的，但是宿主机是真的

![image-20250828000156579](../AppData/Roaming/Typora/typora-user-images/image-20250828000156579.png)

##### 如何操作

![image-20250828004129025](../AppData/Roaming/Typora/typora-user-images/image-20250828004129025.png)

![image-20250828000911455](../AppData/Roaming/Typora/typora-user-images/image-20250828000911455.png)

![image-20250828000655064](../AppData/Roaming/Typora/typora-user-images/image-20250828000655064.png)

含义解释：

- **`Mountpoint`**
   表示这个 Docker Volume 在宿主机（Host）上的实际存储路径。
   换句话说，虽然在容器里你可能把这个 volume 挂载到 `/usr/share/nginx/html` 之类的路径，但在宿主机里，Docker 实际是把数据存在：

  ```
  /var/lib/docker/volumes/html/_data
  ```

![image-20250828002402598](../AppData/Roaming/Typora/typora-user-images/image-20250828002402598.png)

![image-20250828003834732](../AppData/Roaming/Typora/typora-user-images/image-20250828003834732.png)

##### 注意

上面映射的是宿主机上目录，下面映射的是挂载的容器的目录

![image-20250828130345674](../AppData/Roaming/Typora/typora-user-images/image-20250828130345674.png)

#### 本地目录挂载（最常用）

##### 好处

任意指定目录

##### 方法

![image-20250828131744235](../AppData/Roaming/Typora/typora-user-images/image-20250828131744235.png)

##### 语法例子

docker run -d \
--name mysql \
-p 3307:3306 \
-e TZ=Asia/Shanghai \
-e MYSQL_ROOT_PASSWORD=123 \
-v /root/mysql/data:/var/lib/mysql \
-v /root/mysql/conf:/etc/mysql/conf.d \
-v /root/mysql/init:/docker-entrypoint-initdb.d \
mysql:8

#### 本地镜像

##### 简介

![image-20250828142759140](../AppData/Roaming/Typora/typora-user-images/image-20250828142759140.png)

![image-20250828143007187](../AppData/Roaming/Typora/typora-user-images/image-20250828143007187.png)

##### 常见指令

![image-20250828143415771](../AppData/Roaming/Typora/typora-user-images/image-20250828143415771.png)

![image-20250828143754186](../AppData/Roaming/Typora/typora-user-images/image-20250828143754186.png)

![image-20250828143842614](../AppData/Roaming/Typora/typora-user-images/image-20250828143842614.png)

![image-20250828151407830](../AppData/Roaming/Typora/typora-user-images/image-20250828151407830.png)

#### 网络

##### 简介

![image-20250828152929488](../AppData/Roaming/Typora/typora-user-images/image-20250828152929488.png)

##### 命令

**创建自定义网络，容器连接到自定义网络，容器之间通信可以用名字**

![image-20250828153000725](../AppData/Roaming/Typora/typora-user-images/image-20250828153000725.png)

#### 部署

##### 步骤

后端部署

![image-20250828161221309](../AppData/Roaming/Typora/typora-user-images/image-20250828161221309.png)

![image-20250828162032925](../AppData/Roaming/Typora/typora-user-images/image-20250828162032925.png)

前端部署

![image-20250828164952683](../AppData/Roaming/Typora/typora-user-images/image-20250828164952683.png)

下面是整个项目的启动和访问方法：

------



**1. 登录虚拟机**



首先，你需要通过 SSH 或其他方式登录到你的虚拟机。



**2. 启动 Docker 容器**



因为你之前已经创建了 `tlias-server` 和 `nginx-tlias` 这两个容器，所以你不需要再次 `run`（创建）它们。只需使用 `start` 命令来启动它们即可。

Bash

```
# 启动 tlias-server 容器（后端服务）
docker start tlias-server

# 启动 nginx-tlias 容器（前端和反向代理）
docker start nginx-tlias
```



**3. 验证容器是否启动成功**



运行以下命令，确认两个容器都处于 `Up`（运行中）状态。

Bash

```
docker ps
```

如果看到 `tlias-server` 和 `nginx-tlias` 的状态都显示为 `Up`，那就说明它们已经成功运行了。



**4. 访问项目**



现在，你可以通过 Nginx 的 IP 地址来访问你的项目。

- **项目 IP**：`192.168.100.128`
- **访问地址**：`http://192.168.100.128`

因为 Nginx 容器的 `80` 端口已经映射到了虚拟机的 `80` 端口，所以你不需要在地址后面加上 `:80`。



**总结**



下次只需要记住两个简单的命令：`docker start tlias-server` 和 `docker start nginx-tlias`，项目就会重新运行起来了。

##### DockerCompose

![image-20250828174120697](../AppData/Roaming/Typora/typora-user-images/image-20250828174120697.png)

![image-20250828174230416](../AppData/Roaming/Typora/typora-user-images/image-20250828174230416.png)

![image-20250828175146776](../AppData/Roaming/Typora/typora-user-images/image-20250828175146776.png)

### 连接python的fastapi

#### **RestTemplate 发送 HTTP 请求**

##### 核心工具：`RestTemplate`（Spring提供的HTTP客户端）

```java
private String callFastAPI(String question) {
    try {
        String apiUrl = "http://localhost:8000/model_get_result";  // 目标API地址
        Map<String, String> request = new HashMap<>();  // 请求参数（JSON格式）
        request.put("question", question);

        // 发送POST请求并接收响应（自动反序列化为AiResponse对象）
        AiResponse response = restTemplate.postForObject(apiUrl, request, AiResponse.class);
        // ... 处理响应 ...
    } catch (Exception e) {
        // ... 异常处理 ...
    }
}
```

- `RestTemplate`

  ：Spring提供的用于发送HTTP请求的工具类，简化了RESTful API调用。核心方法

   

  ```
  postForObject
  ```

   

  功能：

  - 发送 **POST请求** 到 `apiUrl`；
  - 自动将 `request`（Map类型）转换为JSON请求体；
  - 自动将API返回的JSON响应 **反序列化为 `AiResponse` 对象**（需配合POJO类实现）。











# 苍穹外卖

## 重要小知识点

### 1.快捷方式

#### 1.1TODO

可以提醒自己修改

![image-20250910112631416](../AppData/Roaming/Typora/typora-user-images/image-20250910112631416.png)

#### 1.2ctrl+i

快速重写父类方法



#### 1.3./和../

**总结对比**

| 符号     | 名称               | 含义                         | 示例（当前在 `/a/b/` 目录）       |
| :------- | :----------------- | :--------------------------- | :-------------------------------- |
| `./`     | **当前目录**       | 指向当前所在的文件夹         | `./file.txt` 表示 `/a/b/file.txt` |
| `../`    | **父目录**         | 指向当前文件夹的上一级文件夹 | `../file.txt` 表示 `/a/file.txt`  |
| `../../` | **父目录的父目录** | 可以连续使用向上跳转多级     | `../../file.txt` 表示 `/file.txt` |













### 2.注意

#### 2.1数据库存的密码要加密

![image-20250910112947043](../AppData/Roaming/Typora/typora-user-images/image-20250910112947043.png)

#### 2.2DTO封装

用对象封装可以，但是封装部分数据最好选择DTO

```
@Data
public class EmployeeDTO implements Serializable {

    private Long id;

    private String username;

    private String name;

    private String phone;

    private String sex;

    private String idNumber;

}
```

#### 2.3泛型是什么

1.`Result` 类声明中的 `<T>`

```
public class Result<T> implements Serializable {
    // ...
    private T data; // 数据
    // ...
}
```

这里的 `<T>` 声明了 `Result` 是一个**泛型类**。这意味着在创建 `Result` 类的对象时，你可以指定它要携带的数据（`data` 字段）是什么类型。



2. 泛型静态方法

`success()` 和 `success(T object)` 这两个静态方法也使用了泛型。

- **`public static <T> Result<T> success()`** 这个方法返回一个成功的 `Result` 对象，但**不包含任何数据**。虽然方法本身不使用 `T` 作为参数，但它返回的 `Result` 对象需要一个类型。这里的 `<T>` 是一个**泛型方法声明**，它允许你在调用时指定返回的 `Result` 类型，例如 `Result<Void> result = Result.success();`。

- **`public static <T> Result<T> success(T object)`** 这个方法接收一个 `T` 类型的参数 `object`，并返回一个包含该数据的 `Result` 对象。这里的泛型 `<T>` 同样是**泛型方法声明**，它使得这个方法可以处理任何类型的数据。

  例如：

  - `Result<String> r1 = Result.success("操作成功");`
  - `User u = new User(); Result<User> r2 = Result.success(u);`



```java
public static <T> Result<T> success(T object)//前面的<T>是语法类型，后面的是Result类型
```

#### 2.4泛型注意

```java
@GetMapping("/page")
@ApiOperation("员工分页查询")
public Result<PageResult> page(EmployeePageQueryDTO employeePageQueryDTO) {
    log.info("员工分页查询，参数为：{}", employeePageQueryDTO);
    PageResult pageResult = employeeService.pageQuery(employeePageQueryDTO);
    return Result.success(pageResult);
}
//在您提供的代码片段中，方法返回类型声明为 Result<PageResult>，这里的泛型参数 PageResult 仅用于指定该方法返回的 Result 对象的类型参数。它不会自动传播或影响方法内部其他泛型的使用。方法内部的泛型推断是基于各自的上下文独立进行的。
```

#### 2.5不要重复注入对象

```java
@Component和@Bean
```

#### 2.6AliyunOSS文件上传

```java
package com.sky.utils;

import com.aliyun.oss.*;
import com.aliyun.oss.common.auth.CredentialsProviderFactory;
import com.aliyun.oss.common.auth.EnvironmentVariableCredentialsProvider;
import com.aliyun.oss.common.comm.SignVersion;
import com.sky.properties.AliOssProperties;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.extern.slf4j.Slf4j;

import java.io.ByteArrayInputStream;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.UUID;

@Slf4j
@AllArgsConstructor
@Data
public class AliOssUtil {
    private String endpoint;
    private String bucketName;
    private String region;

    public String upload(byte[] content, String originalFilename) throws Exception {
        // 从环境变量中获取访问凭证
        EnvironmentVariableCredentialsProvider credentialsProvider = 
            CredentialsProviderFactory.newEnvironmentVariableCredentialsProvider();

        String dir = LocalDate.now().format(DateTimeFormatter.ofPattern("yyyy/MM"));
        String newFileName = UUID.randomUUID() + originalFilename.substring(originalFilename.lastIndexOf("."));
        String objectName = dir + "/" + newFileName;

        // 创建OSSClient实例（修改这里）
        OSS ossClient = new OSSClientBuilder().build(endpoint, credentialsProvider);

        try {
            ossClient.putObject(bucketName, objectName, new ByteArrayInputStream(content));
        } finally {
            ossClient.shutdown();
        }

        return endpoint.split("//")[0] + "//" + bucketName + "." + endpoint.split("//")[1] + "/" + objectName;
    }
}
```



#### 2.7内连接与外连接

| 连接类型     | 关键字                 | 描述                                | 结果相当于 |
| :----------- | :--------------------- | :---------------------------------- | :--------- |
| **内连接**   | `INNER JOIN` 或 `JOIN` | 只返回两个表中**匹配**的行          | **交集**   |
| **左外连接** | `LEFT JOIN`            | 返回**左表全部** + **右表匹配**的行 | 左表全集   |
| **右外连接** | `RIGHT JOIN`           | 返回**右表全部** + **左表匹配**的行 | 右表全集   |





#### 2.8sql< if >语句

```java
<if test="name != null">//这里的name是传进来的对象的属性
    s.name like concat('%',#{name},'%')
</if>
<if test="categoryId != null">
    s.category_id = #{categoryId}
</if>
```

















### 3.技术



#### 3.1Threadlocal

获取或者存入整个线程的不变量

![image-20250911163655563](../AppData/Roaming/Typora/typora-user-images/image-20250911163655563.png)

```java
public class ThreadLocalDemo {
    private static ThreadLocal<String> threadLocal = new ThreadLocal<>();
public static void main(String[] args) {
    // 设置当前线程的线程局部变量的值
    threadLocal.set("主线程的值");
    
    // 返回当前线程所对应的线程局部变量的值
    System.out.println("获取的值: " + threadLocal.get());
    
    // 移除当前线程的线程局部变量
    threadLocal.remove();
    
    // 再次尝试获取（应为null）
    System.out.println("移除后获取的值: " + threadLocal.get());
}
}
```

![image-20250911163957405](../AppData/Roaming/Typora/typora-user-images/image-20250911163957405.png)



#### 3.2父类与子类

**下面这话的意思是子类在某种程度上称作父类**

从里氏替换原则（Liskov Substitution Principle） 的角度，子类可以被视为与父类“相同类型”——因为子类对象能在不改变程序正确性的前提下，完全替代父类对象使用。

具体来说，这种“类型一致性”体现在Java的语法和设计原则中：

1. 向上转型（自动类型转换）：子类对象可以直接赋值给父类类型的变量，例如  Animal dog = new Dog(); （假设 Dog 继承 Animal ），此时 dog 变量的编译类型是 Animal ，但运行类型是 Dog 。
2. 行为兼容性：子类会继承父类的非私有方法，或通过重写保证方法签名（参数、返回值）与父类一致，因此调用父类方法时，无论实际是父类还是子类对象，都能符合预期逻辑。

但需注意：这是“单向的类型兼容”——父类对象不能被当作子类类型使用（如 Dog d = new Animal(); 会编译报错），因为子类可能有父类没有的属性或方法，父类无法满足子类的类型要求。



#### 3.3PageHelper

```java
PageHelper.startPage(Page,PageSize)//这里是拦截器，为后续sql查询语句增加limit
//例子：
//PageHelper.startPage(employeePageQueryDTO.getPage(),employeePageQueryDTO.getPageSize());
```



#### 3.4统一对日期类型进行格式化处理

在 WebMvcConfiguration 中扩展Spring MVC的消息转换器，统一对日期类型进行格式化处理

![image-20250912152841168](../AppData/Roaming/Typora/typora-user-images/image-20250912152841168.png)

```java
public class JacksonObjectMapper extends ObjectMapper {

    public static final String DEFAULT_DATE_FORMAT = "yyyy-MM-dd";
    //public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss";
    public static final String DEFAULT_DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm";
    public static final String DEFAULT_TIME_FORMAT = "HH:mm:ss";

    public JacksonObjectMapper() {
        super();
        //收到未知属性时不报异常
        this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false);

        //反序列化时，属性不存在的兼容处理
        this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES);

        SimpleModule simpleModule = new SimpleModule()
                .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)))
                .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT)))
                .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT)))
                .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT)));

        //注册功能模块 例如，可以添加自定义序列化器和反序列化器
        this.registerModule(simpleModule);
    }
}

```







#### 3.5快速拷贝对象属性

```java
BeanUtils.copyProperties(employeeDTO,employee)
//前拷到后，且属性名要相同
```



#### 3.6当两个表有多个相同字段

![image-20250913105041963](../AppData/Roaming/Typora/typora-user-images/image-20250913105041963.png)

```java
//优化方法：
自定义注解 AutoFill，用于标识需要进行公共字段自动填充的方法

自定义切面类 AutoFillAspect，统一拦截加入了 AutoFill 注解的方法，通过反射为公共字段赋值

在 Mapper 的方法上加入 AutoFill 注解

技术点：枚举、注解、AOP、反射
```

#### 3.7自定义注解

```java
@Target(ElementType.METHOD)  // 表示这个注解只能用于方法上
@Retention(RetentionPolicy.RUNTIME)  // 表示这个注解在运行时可以通过反射获取
public @interface AutoFill {
    // 数据库操作类型：UPDATE 或 INSERT
    OperationType value();  // 注解的属性，类型为 OperationType 枚举
}
```



```java
//如下是OperationType枚举类内容

/**
 * 更新操作 
 */
UPDATE,  // 表示更新操作的枚举值

/**
 * 插入操作 
 */
INSERT   // 表示插入操作的枚举值
```



#### 3.8切入点拦截

**这个的作用是在自己设置的某个方法执行前或者执行后执行**

```java
//主体部分
@Slf4j
@Component
@Aspect
public class AutoFillAspect {
    @Pointcut("execution(* com.sky.mapper.*.*(..)) && @annotation(com.sky.annotation.AutoFill)")
    public void autoFillPointcut() {

    }

    @Before("autoFillPointcut()")
    public void autoFill(JoinPoint joinPoint) {
        log.info("开始进行自动填充");
    }
}
//这是定义的注解
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface AutoFill {
    OperationType value();
}
//加在某个方法上
@AutoFill(value = OperationType.UPDATE)
```



#### 3.9反射

##### 1.什么是反射

反射（Reflection）是 Java 中的一种强大机制，它允许程序在运行时动态地获取一个类的所有信息，包括类的构造方法、成员变量（字段）和成员方法（函数），而不需要在编译时知道这个类。

##### 2.反射作用

反射主要有以下几个核心用途：

1. **在运行时分析类的结构**：你可以获取一个类中的所有方法、字段、构造器，以及它们的修饰符（public、private 等）、参数类型和返回类型。这对于编写通用工具或框架非常有用。
2. **动态创建对象**：你可以根据类的字符串名称来创建对象，而不需要使用 `new` 关键字。
3. **动态调用方法**：你可以根据方法名字符串来执行方法，并传递参数。
4. **动态操作字段**：你可以根据字段名字符串来读取或修改对象的私有成员变量。



**举个例子**

想象一下你正在开发一个通用的数据库操作框架。这个框架需要将数据库查询的结果（比如一行数据）自动映射到任何一个你定义的 Java 对象上（比如 `User` 对象或 `Product` 对象）。

如果没有反射，你需要为每一种类型的对象（`User`、`Product` 等）都手动编写一遍赋值的代码，非常繁琐。



##### 3.基本方法

```java
1.
    获取构造方法 (Constructor) 并创建对象     getDeclaredConstructor(Class<?>... parameterTypes)：

获取指定参数类型的单个构造方法。

例子：Constructor<?> constructor = userClass.getDeclaredConstructor(String.class, int.class);


2.
	获取成员方法 (Method) 并调用        getDeclaredMethod(String name, Class<?>... parameterTypes)：

获取指定名称和参数类型的单个方法，包括 private 方法。

例子：Method setUserName = userClass.getDeclaredMethod("setUserName", String.class);


3.
    获取成员变量 (Field) 并操作				getDeclaredField(String name)：

获取指定名称的单个成员变量，包括 private 变量。

例子：Field userNameField = userClass.getDeclaredField("userName");


4.
    重要的辅助方法					setAccessible(boolean flag)：

这是一个非常重要的方法，它属于 AccessibleObject 类（Method、Field 和 Constructor 的父类）。

当你需要访问或操作一个 private 的成员（方法、字段、构造方法）时，必须先调用 setAccessible(true) 来禁用 Java 的访问检查，否则会抛出 IllegalAccessException。

   
5.例子：

Method setCreateTime = entity.getClass().getDeclaredMethod("setCreateTime", LocalDateTime.class);
                Method setCreateUser = entity.getClass().getDeclaredMethod("setCreateUser", Long.class);
                Method setUpdateTime = entity.getClass().getDeclaredMethod("setUpdateTime", LocalDateTime.class);
                Method setUpdateUser = entity.getClass().getDeclaredMethod("setUpdateUser", Long.class);
                setCreateTime.invoke(entity, now);
                setCreateUser.invoke(entity, currentId);
                setUpdateTime.invoke(entity, now);
                setUpdateUser.invoke(entity, currentId);
```



#### 3.10@ConfigurationProperties(prefix = "sky.alioss")

```
@ConfigurationProperties(prefix = "sky.alioss")` 会把 `application.yml` 的配置注入属性。
```



#### 3.11配置类作用

##### 0.什么是配置类

```
@Configuration 类本身首先被识别为一个Bean定义（Bean Definition）注册到容器中。你可以把它看作一个生产Bean的“工厂Bean”。
```



##### 1. **集中管理Bean定义**

配置类将应用程序中所有需要由Spring容器管理的对象（Bean）集中在一个地方定义，取代了传统的XML配置文件方式。

##### 2. **依赖注入配置**

配置类可以明确指定Bean之间的依赖关系，Spring容器会自动处理这些依赖的注入。

```java
@Configuration
public class ServiceConfig {
    @Bean
    public TransferService transferService(AccountRepository accountRepository) {
        return new TransferServiceImpl(accountRepository);
    }
}
```

##### 3. **条件化Bean创建**

配置类支持条件化Bean创建，可以根据特定条件决定是否创建某个Bean。

```java
@Configuration
public class ConditionalConfig {
    @Bean
    @ConditionalOnMissingBean // 只在没有同类型Bean时才创建
    public AliOssUtil aliOssUtil(AliOssProperties props) {
        return new AliOssUtil(props.getEndpoint(), props.getBucketName(), props.getRegion());
    }
    
    @Bean
    @ConditionalOnProperty(name = "cache.enabled", havingValue = "true")
    public CacheManager cacheManager() {
        return new RedisCacheManager();
    }
}
```

##### 4. **外部化配置集成**

配置类可以与Spring的配置属性系统集成，轻松读取外部配置文件（如application.yml）中的值。

```java
@Configuration
@EnableConfigurationProperties(AliOssProperties.class)
public class OssConfiguration {
    // 可以直接注入配置属性
    @Bean
    public AliOssUtil aliOssUtil(AliOssProperties props) {
        return new AliOssUtil(props.getEndpoint(), props.getBucketName(), props.getRegion());
    }
}
```

##### 5. **AOP和代理配置**

配置类可以用于配置AOP（面向切面编程）和创建代理对象。

```java
@Configuration
@EnableAspectJAutoProxy
public class AopConfig {
    @Bean
    public LoggingAspect loggingAspect() {
        return new LoggingAspect();
    }
}
```

##### 6.总结

配置类是Spring框架实现"约定优于配置"理念的核心机制，它通过Java代码的方式提供了比XML配置更强大、更灵活、更类型安全的配置方式。配置类使得应用程序的各个组件能够以声明式的方式组合在一起，同时保持了代码的简洁性和可测试性。

在您的项目中，配置类帮助将阿里云OSS工具类的创建和配置集中管理，使代码更加模块化和可维护，同时也为可能的扩展和自定义提供了灵活的机制。



#### 3.12文件技术

```java
// 原始文件名
String originalFilename = file.getOriginalFilename();
// 截取原始文件名的后缀
String extension = originalFilename.substring(originalFilename.lastIndexOf("."));
// 构造新文件名称
String objectName = UUID.randomUUID().toString() + extension;
```



#### 3.13GlobalExceptionHandler

```java
@Slf4j
@RestControllerAdvice//注意这个注解
public class GlobalExceptionHandler {

    @ExceptionHandler
    public Result exceptionHandler(SQLIntegrityConstraintViolationException ex){
        String msgs =ex.getMessage();
        if(msgs.contains("Duplicate entry")){
            String[] split = msgs.split(" ");
            String username = split[2];
            String mg = username+ "已存在";
            return Result.error(mg);
        }
        else{
            return Result.error("未知错误");
        }
    }
}
```



#### 3.14两个yml文件

```java
application.yml
application-dev.yml
//这样的好处是可以提高自己数据的安全性（上面用$，下面再配置值）
//但是上面要配置profile，如下：
spring:
  application:
    name: MyServer
  # 添加这一行来激活dev环境配置
  profiles:
    active: dev
```

#### 3.15Query传多个参数

```java
//?ids=1,2,3
//用@RequestParam接收
public Result delete(@RequestParam List<Long> id)
```

#### 3.16foreach用法

```java
ids.forEach(id -> {
    dishMapper.deleteById(id);
    dishFlavorMapper.deleteByDishId(id);
});
```

#### 3.17PageHelper的page

```java
//这里的page是别人的包封装好的页面（这里没写错）


PageHelper.startPage(setmealPageQueryDTO.getPage(),setmealPageQueryDTO.getPageSize());
Page<Setmeal> page = setmealMapper.pageQuery(setmealPageQueryDTO);
```

















### 4.配置注意

#### 4.1创建xml配置文件

**要用/**

![image-20250912222916308](../AppData/Roaming/Typora/typora-user-images/image-20250912222916308.png)







### 5.设计思想

#### 5.1关于sql

尽量少执行sql语句，即：能批量删除就批量删除





## 重要小前置知识点

#### 1.@RequestBody将json封装在对象里

在 **Spring Boot（Spring MVC）** 里，`@RequestBody` 的作用是：

👉 **把 HTTP 请求体（Request Body）里的 JSON、XML 或表单数据，自动反序列化为 Java 对象，并注入到方法参数中。**

------

###### 🔹 为什么要用 `@RequestBody`？

- HTTP 请求有两部分：**请求头 (headers)** 和 **请求体 (body)**。
- 当客户端发送 **POST/PUT** 请求时，通常会把数据放在请求体里（JSON 比较常见）。
- Spring 默认只能自动解析 **表单键值对（x-www-form-urlencoded）** 这种数据，
  如果你传的是 **JSON**，就需要用 `@RequestBody` 告诉 Spring：**请把请求体里的 JSON 转成 Java 对象**。

------

###### 🔹 示例

###### 1. 不使用 `@RequestBody`（传统表单方式）

```
@PostMapping("/addUser")
public String addUser(String name, Integer age) {
    return "用户: " + name + " 年龄: " + age;
}
```

请求方式（表单）：

```
POST /addUser
Content-Type: application/x-www-form-urlencoded

name=张三&age=20
```

------

###### 2. 使用 `@RequestBody`（JSON 方式）

```
@RestController
public class UserController {
    @PostMapping("/addUser")
    public String addUser(@RequestBody User user) {
        return "用户: " + user.getName() + " 年龄: " + user.getAge();
    }
}
```

`User` 类：

```
public class User {
    private String name;
    private Integer age;
    // getter/setter
}
```

请求方式（JSON 请求体）：

```
POST /addUser
Content-Type: application/json

{
  "name": "张三",
  "age": 20
}
```

Spring 会自动用 **Jackson**（默认的 JSON 解析库）把 JSON 解析成 `User` 对象。

------

######🔹 小结

- `@RequestBody`：取 **请求体数据**，并自动转换为 Java 对象。
- 常用于 `POST` / `PUT` 请求。
- 依赖 `HttpMessageConverter`（默认用 Jackson 处理 JSON）。







#### 2.@RestController

**`@RestController`** 是 Spring Framework 4.0 引入的一个复合注解，它的作用是简化 **RESTful Web 服务**的开发。

它实际上是两个注解的组合：

1. `@Controller`
2. `@ResponseBody`



**`@Controller` 的作用**



`@Controller` 用于标识一个类是 Spring MVC 的控制器。在传统的 MVC 架构中，`@Controller` 负责处理客户端的请求，并将请求分发给相应的服务层进行处理，然后返回一个视图名（如 JSP、Thymeleaf 模板）。



**`@ResponseBody` 的作用**



`@ResponseBody` 通常标注在方法或类上，它的作用是告诉 Spring **不要将方法的返回值解析为视图名称**，而是将返回值直接作为 **HTTP 响应体**（Response Body）返回给客户端。

Spring 会使用内置的 HTTP 消息转换器（`HttpMessageConverter`）来处理这个返回值，通常是将其转换为 **JSON** 或 **XML** 格式。这对于构建返回数据的 API 服务非常重要。





#### 3.基于SpringBoot官方骨架创建的，这些字段会保留

![image-20250811005605843](../AppData/Roaming/Typora/typora-user-images/image-20250811005605843.png)





#### 4.传参的情况

**它可以自动把id提取出来**

![image-20250811010857934](../AppData/Roaming/Typora/typora-user-images/image-20250811010857934.png)

#### 5.@Component的作用(@Service)

在Spring Boot中，`@Component` 注解的作用是**将一个类标记为Spring组件**。

简单来说，当你在一个类上使用 `@Component` 注解时，你就是在告诉Spring框架：“嘿，请管理这个类。在应用启动时，请为我创建一个它的实例（也就是一个 Bean），并把它放到你的容器（Spring IoC Container）里。”

这样一来，这个被标记的类就成为了Spring可以识别和管理的**组件**。其他地方需要使用这个类的实例时，Spring就可以通过**依赖注入**（Dependency Injection）的方式，将它自动装配进来，而不需要你手动去创建和管理实例。

除了 `@Component`，Spring还提供了几个更具特定语义的衍生注解，它们的作用和 `@Component` 基本相同，但用在不同的分层架构中，让代码更清晰、更易懂：

- `@Controller`: 用于标记处理Web请求的类，通常在**控制层**（Controller layer）使用。
- `@Service`: 用于标记包含业务逻辑的类，通常在**服务层**（Service layer）使用。
- `@Repository`: 用于标记处理数据持久化（例如与数据库交互）的类，通常在**数据访问层**（Data access layer）使用。

总的来说，这四个注解的作用都是一样的：将类注册成Spring的组件。选择使用哪一个取决于这个组件在你的应用中扮演的角色。这不仅有助于代码组织，也让开发人员能更快地理解每个类的职责。



#### 6.Autowired

在 Java Spring Boot 中， @Autowired  是 Spring 框架提供的核心注解之一，主要作用是实现依赖的自动注入，帮助开发者简化对象之间依赖关系的管理。

具体来说，它的作用可以拆解为：

1. 自动关联依赖对象
   当一个类（比如  Service 、 Controller  等）需要依赖另一个类的实例时（比如  Service  依赖  Dao ），不需要手动通过  new  创建依赖对象，只需在依赖字段、构造方法或 setter 方法上添加  @Autowired ，Spring 容器会自动从容器中找到匹配的对象，并注入到当前类中。示例：
   @Service
   public class UserService {
    // 自动注入 UserDao 实例
    @Autowired
    private UserDao userDao;

    public void addUser() {
        userDao.save(); // 直接使用注入的 userDao
    }
   }

2. 降低代码耦合度
   传统方式中，需要手动创建依赖对象（如  userDao = new UserDao() ），导致类与类之间强耦合。 @Autowired  让依赖关系由 Spring 容器管理，开发者只需关注业务逻辑，无需关心对象的创建和关联，更符合“依赖倒置原则”。

3. 支持多种注入方式

- 字段注入：直接在成员变量上添加  @Autowired （最常用）。

- 构造方法注入：在构造方法上添加  @Autowired ，Spring 会在创建当前对象时，自动注入构造方法的参数。
  @Service
  public class UserService {
    private UserDao userDao;

    // 构造方法注入
    @Autowired
    public UserService(UserDao userDao) {
        this.userDao = userDao;
    }
  }

- setter 方法注入：在 setter 方法上添加  @Autowired ，Spring 会调用该方法注入依赖。

4. 默认按类型匹配（byType）
   Spring 容器会根据被注入字段的类型（如  UserDao ），在容器中查找相同类型的 bean 并注入。如果存在多个同类型的 bean，会报错，此时需配合  @Qualifier  注解指定具体 bean 的名称：
   @Autowired
   @Qualifier("userDaoImpl") // 指定注入名称为 userDaoImpl 的 bean
   private UserDao userDao;

5. 可配置是否必须注入
   @Autowired  有个  required  属性（默认  true ），表示依赖必须存在，否则会报错。若设为  false ，则当依赖不存在时，注入  null ：
   @Autowired(required = false)
   private UserDao userDao;


总之， @Autowired  是 Spring 实现“控制反转（IOC）”和“依赖注入（DI）”的关键注解，极大简化了对象依赖的管理，是 Spring Boot 开发中最常用的注解之一。

#### 7.RequestParam设置默认值

![image-20250811140433455](../AppData/Roaming/Typora/typora-user-images/image-20250811140433455.png)

在 Spring Boot 中，`@RequestParam` 是一个非常常用的注解，它的主要作用是**将 HTTP 请求中的参数绑定到你的控制器（Controller）方法的参数上**。简单来说，就是当你的浏览器发送一个带参数的请求到你的服务器时，Spring Boot 框架能通过 `@RequestParam` 自动把这些参数的值“抓取”过来，并赋值给你方法中定义的变量，这样你就可以在业务逻辑中直接使用这些参数了。



###### 1. 最简单的用法



假设你有一个接口，需要接收一个名为 `name` 的字符串参数。

Java

```
@GetMapping("/hello")
public String hello(@RequestParam String name) {
    return "Hello, " + name + "!";
}
```

当你访问 `http://localhost:8080/hello?name=Gemini` 时，Spring Boot 会找到 `name=Gemini` 这个参数，然后把它赋值给 `hello` 方法里的 `name` 变量。所以，最终你会得到一个返回结果："Hello, Gemini!"。



###### 2. 参数名不一致时的用法



如果你的请求参数名和方法参数名不一致，你可以通过 `@RequestParam` 的 `value`（或者 `name`）属性来指定。

Java

```
@GetMapping("/user")
public String getUser(@RequestParam("userId") String id) {
    return "User ID is: " + id;
}
```

在这种情况下，你需要访问 `http://localhost:8080/user?userId=123`，而不是 `?id=123`。



###### 3. 设定参数为非必传（可选）



默认情况下，使用 `@RequestParam` 标记的参数都是**必传**的。如果请求中没有这个参数，Spring Boot 会抛出一个 `MissingServletRequestParameterException` 异常。

如果你想让一个参数变成可选的，可以通过设置 `required = false`。

Java

```
@GetMapping("/greet")
public String greet(@RequestParam(value = "name", required = false) String name) {
    if (name == null || name.isEmpty()) {
        return "Hello, Guest!";
    }
    return "Hello, " + name + "!";
}
```

现在，当你访问 `http://localhost:8080/greet`（没有带参数）时，`name` 参数会被赋值为 `null`，程序会正常执行。当你访问 `http://localhost:8080/greet?name=Lily` 时，`name` 的值就是 "Lily"。

------



###### 4. 设定默认值



当你把参数设为可选后，你还可以通过 `defaultValue` 属性为它指定一个默认值，这样就不用再手动判断 `null` 了。

Java

```
@GetMapping("/search")
public String search(@RequestParam(defaultValue = "1") int page) {
    return "Searching on page: " + page;
}
```

在这个例子中，如果你访问 `http://localhost:8080/search`，`page` 的值会自动变成 `1`。如果你访问 `http://localhost:8080/search?page=5`，`page` 的值就是 `5`。

------



###### 5. 接收多个同名参数



如果你的请求中有多个同名的参数（比如一个复选框），你可以使用一个集合类型来接收它们。

Java

```
@GetMapping("/items")
public String getItems(@RequestParam List<String> itemIds) {
    return "Selected items: " + String.join(", ", itemIds);
}
```

当你访问 `http://localhost:8080/items?itemIds=101&itemIds=102&itemIds=103` 时，`itemIds` 将会是一个包含 `["101", "102", "103"]` 的列表。





#### 8.查看并下载依赖的网站

https://mvnrepository.com/

#### 9.注意重要判断函数

false非空，true空

![image-20250813165334804](../AppData/Roaming/Typora/typora-user-images/image-20250813165334804.png)

#### 10.获取主键Id

![image-20250814133036081](../AppData/Roaming/Typora/typora-user-images/image-20250814133036081.png)

![image-20250814175019118](../AppData/Roaming/Typora/typora-user-images/image-20250814175019118.png)

![image-20250814175047241](../AppData/Roaming/Typora/typora-user-images/image-20250814175047241.png)

#### 11.防止其他事务回滚影响

![image-20250814225749116](../AppData/Roaming/Typora/typora-user-images/image-20250814225749116.png)

![image-20250814230453904](../AppData/Roaming/Typora/typora-user-images/image-20250814230453904.png)

#### 12.某些东西可以放在配置文件中

两种方法

![image-20250816161530011](../AppData/Roaming/Typora/typora-user-images/image-20250816161530011.png)

![image-20250816160143157](../AppData/Roaming/Typora/typora-user-images/image-20250816160143157.png)

#### 13.内连接和外连接

| 连接类型     | 关键字                 | 描述                                | 结果相当于 |
| :----------- | :--------------------- | :---------------------------------- | :--------- |
| **内连接**   | `INNER JOIN` 或 `JOIN` | 只返回两个表中**匹配**的行          | **交集**   |
| **左外连接** | `LEFT JOIN`            | 返回**左表全部** + **右表匹配**的行 | 左表全集   |
| **右外连接** | `RIGHT JOIN`           | 返回**右表全部** + **左表匹配**的行 | 右表全集   |

#### 14.修改方法

先删后存

#### 15.《set》和《where》标签

![image-20250817120250975](../AppData/Roaming/Typora/typora-user-images/image-20250817120250975.png)

#### 16.全局异常处理

![image-20250817204303527](../AppData/Roaming/Typora/typora-user-images/image-20250817204303527.png)



**这里的错误信息会从下往上检查是哪个问题（就是从最子类检查到最父类）**

![image-20250817210029213](../AppData/Roaming/Typora/typora-user-images/image-20250817210029213.png)

![image-20250817210830728](../AppData/Roaming/Typora/typora-user-images/image-20250817210830728.png)

#### 17.注意SQL细节

如果您使用 MyBatis 插入一个完整的对象，MyBatis 会自动处理字段映射。

XML

```
<insert id="insert" parameterType="com.it.pojo.Clazz">
    insert into clazz
    (id, name, room, begin_date, end_date, master_id, subject, create_time, update_time)
    values
    (#{id}, #{name}, #{room}, #{beginDate}, #{endDate}, #{masterId}, #{subject}, #{createTime}, #{updateTime})
</insert>
```

**重要提示：**

- 如果您的 `id` 字段是数据库自动生成的（例如，使用 `AUTO_INCREMENT`），则应该在 SQL 语句中省略 `id` 字段。
- 如果 `createTime` 和 `updateTime` 字段是由数据库自动填充的，您也应该在插入时省略它们。
- 这个 `insert` 语句假设您有一个方法，例如 `insert(Clazz clazz)`，它将一个 `Clazz` 对象作为参数。MyBatis 会自动将 `Clazz` 对象中的属性值映射到 `#{...}` 占位符。

#### 18.@Bean

在 **Spring / Spring Boot** 里，`@Bean` 的作用就是：

👉 **告诉 Spring 容器：我要往 IOC 容器里注册一个 Bean（对象），并交给 Spring 来管理它的生命周期。**

------

##### 🔹 基本概念

- **Bean**：就是由 Spring 容器管理的对象。

- 在以前我们写 `applicationContext.xml` 的时候，要手动写：

  ```
  <bean id="myService" class="com.example.MyService"/>
  ```

- 现在用 Java 配置时，只要写个方法加上 `@Bean`，返回一个对象，Spring 就会把这个对象放进容器里。

------

##### 🔹 示例

```
@Configuration  // 表示这是一个配置类，等价于一个 Spring XML 配置文件
public class AppConfig {

    @Bean   // 向 Spring 容器注册一个 Bean
    public MyService myService() {
        return new MyService(); // 这个对象会被 Spring 容器托管
    }
}
```

这样，Spring 容器里就有了一个名字为 `myService` 的 Bean。
 你就可以在别的地方注入使用：

```
@RestController
public class TestController {
    private final MyService myService;

    public TestController(MyService myService) {
        this.myService = myService;
    }

    @GetMapping("/hello")
    public String hello() {
        return myService.sayHello();
    }
}
```

------

##### 🔹 细节

1. **Bean 名字**

   - 默认：方法名就是 Bean 的名字（上例中是 `myService`）。

   - 也可以指定：

     ```
     @Bean("customService")
     public MyService myService() { ... }
     ```

2. **和 @Component 的区别**

   - `@Component`：直接标在类上，由 **类扫描** 注册成 Bean。
   - `@Bean`：标在 **方法上**，手动指定返回的对象。
   - 一般 `@Component` 用在自己写的业务类；
     `@Bean` 用在第三方类或需要自己构造的对象。

3. **生命周期**

   - Spring 管理 Bean 的创建、初始化、销毁。
   - 可以配合 `@Scope("prototype")` 指定作用域。

------

✅ **一句话总结：**
 `@Bean` 就是 **注册一个方法返回的对象到 Spring 容器**，让它变成一个 Bean，后续可以在项目里通过依赖注入来使用







很多人一开始都会觉得：**有了 `@Component`，为啥还要 `@Bean`？**
 其实这两个注解虽然最终效果都是 **往 Spring 容器里注册一个 Bean**，但 **应用场景完全不同**。

------

##### 🔹 1. `@Component` 适用场景

- **你能改源码**，类是你自己写的。

- 直接在类上加：

  ```
  @Component
  public class MyService { ... }
  ```

- Spring 会自动通过 **包扫描** 发现并注册这个类为 Bean。

- 适合普通的业务逻辑类、Controller、Service、Repository 等。

------

##### 🔹 2. `@Bean` 适用场景

- **你不能改源码**，比如第三方库的类（`DataSource`、`RestTemplate` 等）。

- 或者 **实例化这个 Bean 需要额外逻辑**（构造参数、配置、初始化等）。

- 举例：

  ```
  @Configuration
  public class AppConfig {
      
      @Bean
      public RestTemplate restTemplate() {
          // 这里你可以定制化，比如加拦截器
          return new RestTemplate();
      }
  
      @Bean
      public DataSource dataSource() {
          HikariDataSource ds = new HikariDataSource();
          ds.setJdbcUrl("jdbc:mysql://localhost:3306/test");
          ds.setUsername("root");
          ds.setPassword("1234");
          return ds;
      }
  }
  ```

- 如果是第三方类（比如 `RestTemplate`），你不能在源码上加 `@Component`，只能用 `@Bean`。

------

##### 🔹 3. 二者关系

- `@Component` 走 **类扫描**。
- `@Bean` 走 **方法工厂**。
- 其实它们都只是 **不同的 Bean 定义方式**，最终效果一样：对象交给 Spring 容器管理。

------

##### 🔹 总结类比

- **`@Component`**：像是在类上打一个 “自动注册” 标签 → Spring 扫描到就帮你托管。
- **`@Bean`**：像是自己写了一段 “生产这个对象的方法” → 把方法返回的对象交给 Spring 托管。

------

👉 一句话：

- 如果是 **自己写的类** → 用 `@Component`（更简洁）。
- 如果是 **第三方类** 或 **需要复杂初始化的对象** → 用 `@Bean`。



#### 19.SQL小技巧

```
update_time timestamp not null default current_timestamp on update current_timestamp comment '更新时间',
```

- `timestamp`：这是数据类型。A`timestamp`存储日期和时间，通常采用 UTC 格式。这是一种追踪特定时刻的有效方法。
- `default current_timestamp`：这会将 的初始值设置`update_time`为插入新行时的当前时间戳。因此，`create_time`和`update_time`在新行首次创建时将保持不变。
- `on update current_timestamp`**：这是关键的区别。每当该行中的任何其他列发生更改时，**它都会自动将的值更新`update_time`为当前时间戳。这是一个非常有用的功能，无需在应用程序中编写额外的代码即可跟踪记录的修改。

------



 **`CONSTRAINT`**



```
constraint chk_phone_length check (char_length(phone) = 11)
```

- `constraint chk_phone_length`：这为约束提供了一个名称。命名后，如果需要，可以更轻松地管理、引用或删除约束。
- `check (...)`：这是一个**`CHECK`约束**。它定义了列中的数据必须满足的规则。如果您尝试插入或更新违反此规则的值的行，则操作将失败并返回错误。
- `char_length(phone) = 11`：这是规则。该`CHAR_LENGTH()`函数返回字符串中的字符数。此规则确保该`phone`列**必须恰好包含 11 个字符**。任何少于或多于 11 个字符的值都将被拒绝。

#### 20.简便写日期方法

```
@DateTimeFormat(pattern = "yyyy-MM-dd")
private LocalDate begin;
```

#### 21.WebConfig

![image-20250904215506470](../AppData/Roaming/Typora/typora-user-images/image-20250904215506470.png)

`@Configuration`: 这是一个 Spring 框架的注解，表明这个类是一个配置类。在 Spring 容器启动时，会扫描并加载这个类，并根据其中的配置来创建和配置 bean。（注意这个类没创建Bean，AAutowired下面是别人已经创建好的）。



`public void addInterceptors(InterceptorRegistry registry)`: 这是 `WebMvcConfigurer` 接口中的一个方法，用于注册拦截器。

- `registry.addInterceptor(tokeninterceptor)`: 将 `tokeninterceptor` 注册为一个拦截器。
- `.addPathPatterns("/**")`: 这个方法指定了拦截器要拦截的 URL 路径模式。`"/**"` 是一个通配符，表示拦截所有的 URL 路径。这意味着，当任何请求进入你的应用程序时，`Tokeninterceptor` 都会被执行。



这段代码的作用是**将一个名为 `Tokeninterceptor` 的拦截器注册到 Spring MVC 应用程序中，并让它拦截所有请求**。

#### 22.Interceptor拦截

```
public class Tokeninterceptor implements HandlerInterceptor
```

#### 23.Transactional方法

```
@Transactional(propagation = Propagation.REQUIRES_NEW)
```

1. **propagation = Propagation.REQUIRES_NEW 参数**：
   - 表示事务传播行为设置为 REQUIRES_NEW 模式。
   - 这意味着**每次调用此方法时都会创建一个全新的独立事务**。
   - 如果调用此方法的外层方法已经存在事务，则外层事务会被挂起，直到当前方法的新事务完成后再恢复。
2. **在当前代码中的应用场景**：
   - EmpLogServiceImpl 是一个日志服务实现类，insertLog 方法用于插入操作日志。
   - 使用 REQUIRES_NEW 传播特性，确保日志记录操作**不受外层业务事务的影响**。
   - 即使外层业务操作失败回滚，日志记录仍然会被成功保存，这对于系统审计、问题排查和数据追踪非常重要。

#### 24.动态sql

![image-20250910150548624](../AppData/Roaming/Typora/typora-user-images/image-20250910150548624.png)

![image-20250910150605339](../AppData/Roaming/Typora/typora-user-images/image-20250910150605339.png)

#### 25.配置类

在 Spring 里，想让某个对象被 IoC 容器管理，有两种常见方式：

1. **注解扫描（最常见）**
   在类上加 `@Component` / `@Service` / `@Controller`，Spring 会自动扫描并注册为 Bean。
2. **显式注册（配置类方式）**
   通过一个配置类，用 `@Bean` 方法手动告诉 Spring：“这个方法返回的对象，要放进 IoC 容器里，成为一个 Bean”。

------

##### 2. 配置类显式注册 Bean 的写法

```
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration  // 表示这是一个配置类，相当于以前的 XML 配置文件
public class AppConfig {

    @Bean  // 显式告诉 Spring：把这个方法返回的对象注册为 Bean
    public UserService userService() {
        return new UserService();
    }
}
```

##### 3. 原理

- `@Configuration` 表示这个类是一个配置类（类似以前的 XML `<beans>`）。
- `@Bean` 注解的方法，返回的对象会被 **显式加入 IoC 容器**。
- 即使 `UserService` 类本身没有 `@Component` 注解，也能被容器管理。

##### 4. 使用场景

什么时候需要用 **显式注册**呢？

1. 你无法在类上加 `@Component`（比如这是第三方库里的类，没法改源码）。

   ```
   @Bean
   public ObjectMapper objectMapper() {
       return new ObjectMapper();
   }
   ```

2. 你需要对 Bean 的创建过程做一些定制化处理。

   ```
   @Bean
   public DataSource dataSource() {
       HikariDataSource ds = new HikariDataSource();
       ds.setJdbcUrl("jdbc:mysql://localhost:3306/test");
       ds.setUsername("root");
       ds.setPassword("123456");
       return ds;
   }
   ```

3. 想给容器里注册多个不同配置的同类对象（用 `@Bean(name="xxx")` 区分）。























## 项目前置配置

### 项目结构

![image-20250908224935231](../AppData/Roaming/Typora/typora-user-images/image-20250908224935231.png)

### nginx

#### 为什么使用

![image-20250910105822945](../AppData/Roaming/Typora/typora-user-images/image-20250910105822945.png)

![image-20250910105748636](../AppData/Roaming/Typora/typora-user-images/image-20250910105748636.png)

#### 操作原理

##### 配置方式

![image-20250910110656769](../AppData/Roaming/Typora/typora-user-images/image-20250910110656769.png)

##### 分给箭头的几个服务器

![image-20250910111101001](../AppData/Roaming/Typora/typora-user-images/image-20250910111101001.png)

![image-20250910111326717](../AppData/Roaming/Typora/typora-user-images/image-20250910111326717.png)

### Swagger

#### 简介（什么用）

![image-20250910154121573](../AppData/Roaming/Typora/typora-user-images/image-20250910154121573.png)

![image-20250910154311570](../AppData/Roaming/Typora/typora-user-images/image-20250910154311570.png)

![image-20250910170100027](../AppData/Roaming/Typora/typora-user-images/image-20250910170100027.png)

#### 常用注解

![image-20250910170347582](../AppData/Roaming/Typora/typora-user-images/image-20250910170347582.png)





## Redis

### 1.基础

#### 1.1简介

```
Redis是一个基于内存的 key-value 结构数据库。

- 基于内存存储，读写性能高  
- 适合存储热点数据（热点商品、资讯、新闻）  
- 企业应用广泛
```

#### 1.2启动与连接

```
//启动
redis-server.exe redis.windows.conf
//连接
redis-cli.exe
```



**或者**



```
redis-cli.exe -h localhost -p 6379 -a Gongyusong666
```

**这个命令的意思是：**

这是一个用于连接 Redis 数据库的命令行工具命令。

- `redis-cli.exe`: Redis 自带的命令行客户端程序。
- `-h localhost`: 指定要连接的 Redis 服务器地址为本地机器 (`localhost`)。
- `-p 6379`: 指定要连接的 Redis 服务器端口号为 `6379` (这是 Redis 的默认端口)。

### 2.Redis数据类型及特点

#### 2.1数据类型

Redis存储的是key-value结构的数据，其中key是字符串类型，value有5种常用的数据类型：

- 字符串 string
- 哈希 hash
- 列表 list
- 集合 set
- 有序集合 sorted set / zset

#### 2.2特点

![image-20250919163523810](../AppData/Roaming/Typora/typora-user-images/image-20250919163523810.png)

### 3.Redis常用命令

#### 3.1简介

**Redis常用命令**

- 字符串操作命令  
- 哈希操作命令  
- 列表操作命令  
- 集合操作命令  
- 有序集合操作命令  
- 通用命令  

#### 3.2字符串常用命令

```Redis
Redis 字符串类型常用命令：

- SET key value          设置指定key的值
- GET key                获取指定key的值
- SETEX key seconds value  设置指定key的值，并将 key 的过期时间设为 seconds 秒
- SETNX key value        只有在 key 不存在时设置 key 的值
```

#### 3.3哈希操作命令

```Redis
Redis hash 是一个string类型的 field 和 value 的映射表，hash特别适合用于存储对象，常用命令：

- HSET key field value
  将哈希表 key 中的字段 field 的值设为 value

- HGET key field
  获取存储在哈希表中指定字段的值

- HDEL key field
  删除存储在哈希表中的指定字段

- HKEYS key
  获取哈希表中所有字段

- HVALS key
  获取哈希表中所有值
```

#### 3.4列表操作命令

**头插法**

![image-20250919171722642](../AppData/Roaming/Typora/typora-user-images/image-20250919171722642.png)

```Redis
Redis 列表是简单的字符串列表，按照插入顺序排序，常用命令：

- LPUSH key value1 [value2]
  将一个或多个值插入到列表头部

- LRANGE key start stop
  获取列表指定范围内的元素

- RPOP key
  移除并获取列表最后一个元素

- LLEN key
  获取列表长度
```

#### **3.5集合操作命令**

Redis Set 是 string 类型的无序集合。集合成员是唯一的，这意味着集合中不能出现重复的数据。

其常用命令包括：

```Redis
- **SADD key member1 [member2]**
  向集合 (key) 中添加一个或多个成员。
- **SMEMBERS key**
  返回集合 (key) 中的所有成员。
- **SCARD key**
  获取集合 (key) 的成员数量。
- **SINTER key1 [key2]**
  返回给定所有集合的交集。
- **SUNION key1 [key2]**
  返回所有给定集合的并集。
- **SREM key member1 [member2]**
  移除并删除集合 (key) 中一个或多个成员。
```

#### 3.6有序集合操作命令

Redis 的有序集合是由字符串元素组成的集合，**不允许重复成员**，每个元素都关联一个 `double` 类型的分数（score）。常用命令如下：

| 命令        | 语法                                           | 说明                                                         |
| :---------- | :--------------------------------------------- | :----------------------------------------------------------- |
| **ZADD**    | `ZADD key score1 member1 [score2 member2 ...]` | 向有序集合中添加一个或多个成员（或更新已存在成员的分数）     |
| **ZRANGE**  | `ZRANGE key start stop [WITHSCORES]`           | 通过索引区间返回有序集合中指定区间内的成员（可选是否返回分数） |
| **ZINCRBY** | `ZINCRBY key increment member`                 | 对有序集合中指定成员的分数加上增量 `increment`               |
| **ZREM**    | `ZREM key member [member ...]`                 | 移除有序集合中的一个或多个成员                               |

#### 3.7通用操作命令

这些命令适用于所有 Redis 数据类型，是通用的键（key）管理命令：

| 命令       | 语法           | 说明                                    |
| :--------- | :------------- | :-------------------------------------- |
| **KEYS**   | `KEYS pattern` | 查找所有符合给定模式 (`pattern`) 的 key |
| **EXISTS** | `EXISTS key`   | 检查给定的 key 是否存在                 |
| **TYPE**   | `TYPE key`     | 返回 key 所储存的值的类型               |
| **DEL**    | `DEL key`      | 在 key 存在时删除 key                   |

### 4.Redis在Java

#### 4.1配置

![image-20250920114354181](../AppData/Roaming/Typora/typora-user-images/image-20250920114354181.png)

![image-20250920114521332](../AppData/Roaming/Typora/typora-user-images/image-20250920114521332.png)

#### 4.2创建RedisTemplate对象

```java
@Configuration
@Slf4j
public class RedisConfiguration {
    @Bean
    public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){
        log.info("开始创建Redis模板对象");
        RedisTemplate redisTemplate = new RedisTemplate();
        //设置redis的连接工厂对象
        redisTemplate.setConnectionFactory(redisConnectionFactory);
        //设置redis的key的序列化器
        redisTemplate.setKeySerializer(new StringRedisSerializer());
        return redisTemplate;
    }
}
```

#### 4.3常用命令

##### 4.3.1 String（字符串）类型操作总结

**String（字符串）类型操作总结 (testString 方法)**

| 操作                             | 代码示例                                                     | 说明                                                         |
| :------------------------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
| **设置值**                       | `redisTemplate.opsForValue().set("name", "张三");`           | 设置一个键值对。                                             |
| **获取值**                       | `String name = (String) redisTemplate.opsForValue().get("name");` | 根据键获取对应的值。                                         |
| **设置值（含过期时间）**         | `set("code", "123456", 30, TimeUnit.SECONDS);`               | 设置一个键值对，并指定其存活时间为 30 秒。`TimeUnit` 是时间单位枚举（秒、分、时等）。 |
| **条件设置 (SET if not exists)** | `setIfAbsent("lock", "1")`                                   | **分布式锁的基础实现**。如果键 `lock` 不存在，则设置其值为 `1` 并返回 `true`；如果已存在，则不进行任何操作并返回 `false`。代码中第二次设置会失败。 |

**String 类型特点**：一个 Key 对应一个简单的 Value，是 Redis 中最基础的数据结构。



##### 4.3.2 Hash（哈希/字典）类型操作总结 (testHash 方法)

Hash 类似于 Java 中的 `Map<String, Object>`，它适合存储对象。

| 操作               | 代码示例                                     | 说明                                                         |
| :----------------- | :------------------------------------------- | :----------------------------------------------------------- |
| **添加/修改字段**  | `hashOperations.put("100", "name", "张三");` | 向键为 `100` 的 Hash 结构中添加一个字段 `name`，值为 `张三`。如果字段已存在，则更新其值。 |
| **获取字段值**     | `hashOperations.get("100", "name");`         | 获取键 `100` 的 Hash 结构中字段 `name` 对应的值。            |
| **获取所有字段名** | `hashOperations.keys("100");`                | 获取键 `100` 的 Hash 结构中所有的字段名（field）。返回一个 `Set`。 |
| **获取所有字段值** | `hashOperations.values("100");`              | 获取键 `100` 的 Hash 结构中所有的值（value）。返回一个 `List`。 |
| **删除字段**       | `hashOperations.delete("100", "age");`       | 删除键 `100` 的 Hash 结构中的一个或多个字段（这里是 `age`）。 |

**Hash 类型特点**：一个 Key 对应一个 Field-Value 的映射表，非常适合存储对象（如用户信息、商品信息）。



##### 4.3.3 List（列表）类型操作总结 (`testList` 方法)

List 是一个双向链表，元素有序且可重复。常用于消息队列、最新列表等场景。

| 操作           | 代码示例                             | 对应 Redis 命令      | 说明                                                         |
| :------------- | :----------------------------------- | :------------------- | :----------------------------------------------------------- |
| **批量左推入** | `leftPushAll("mylist", "a","b","c")` | `LPUSH mylist a b c` | 将一个或多个值**从左端**（头部）插入列表。结果是 `c, b, a`。 |
| **左推入**     | `leftPush("mylist", "d")`            | `LPUSH mylist d`     | 将单个值从左端插入列表。结果是 `d, c, b, a`。                |
| **获取范围**   | `range("mylist", 0, -1)`             | `LRANGE mylist 0 -1` | 获取列表中指定范围的元素。`0` 起始索引，`-1` 表示直到末尾。  |
| **右弹出**     | `rightPop("mylist")`                 | `RPOP mylist`        | **移除并返回**列表**右端**（尾部）的元素。这是实现队列的关键（FIFO）。 |
| **获取长度**   | `size("mylist")`                     | `LLEN mylist`        | 获取列表的长度（元素个数）。                                 |

**List 类型特点**：有序、可重复，支持从两端操作。左推右弹是栈（LIFO），左推左弹/右推右弹是队列（FIFO）。



##### 4.3.4 Set（集合）类型操作总结 (`testSet` 方法)

Set 是无序的字符串集合，元素不可重复，支持高效的集合运算。常用于标签、共同好友、抽奖等场景。

| 操作             | 代码示例                       | 对应 Redis 命令     | 说明                                   |
| :--------------- | :----------------------------- | :------------------ | :------------------------------------- |
| **添加元素**     | `add("set1", "a","b","c","d")` | `SADD set1 a b c d` | 向集合中添加一个或多个成员，自动去重。 |
| **获取所有元素** | `members("set1")`              | `SMEMBERS set1`     | 返回集合中的所有成员。**注意：无序**。 |
| **获取元素个数** | `size("set1")`                 | `SCARD set1`        | 返回集合的基数（元素数量）。           |
| **求交集**       | `intersect("set1", "set2")`    | `SINTER set1 set2`  | 返回两个集合的交集（共有的元素）。     |
| **求并集**       | `union("set1", "set2")`        | `SUNION set1 set2`  | 返回两个集合的并集（所有的元素）。     |
| **移除元素**     | `remove("set1", "a","b")`      | `SREM set1 a b`     | 移除集合中一个或多个成员。             |

**Set 类型特点**：无序、唯一，提供强大的集合运算能力。



##### 4.3.5 ZSet（有序集合）类型操作总结 (`testZset` 方法)

ZSet 与 Set 类似，但每个元素都会关联一个 `score`（分数），用于排序。元素唯一，但 `score` 可以重复。适用于排行榜、带权重的队列等场景。

| 操作               | 代码示例                           | 对应 Redis 命令      | 说明                                                         |
| :----------------- | :--------------------------------- | :------------------- | :----------------------------------------------------------- |
| **添加元素**       | `add("zset1", "a", 10)`            | `ZADD zset1 10 a`    | 向有序集合中添加一个成员及其分数。                           |
| **按索引范围获取** | `range("zset1", 0, -1)`            | `ZRANGE zset1 0 -1`  | 按分数**从小到大**的顺序返回索引范围内的成员（**不包含分数**）。`ZREVRANGE` 为从大到小。 |
| **增加分数**       | `incrementScore("zset1", "c", 10)` | `ZINCRBY zset1 10 c` | 为指定成员的分数增加增量 `delta`。是实现排行榜计数更新的核心操作。 |
| **移除元素**       | `remove("zset1", "a","b")`         | `ZREM zset1 a b`     | 移除有序集合中的一个或多个成员。                             |

**ZSet 类型特点**：唯一、有序（通过分数排序），是实现排行榜等功能的首选数据结构。



##### 4.3.6 通用键操作总结 (`testCommon` 方法)

这些命令不针对特定数据类型，而是用于管理所有的键。

| 操作               | 代码示例           | 对应 Redis 命令 | 说明                                                         |
| :----------------- | :----------------- | :-------------- | :----------------------------------------------------------- |
| **模式匹配查询键** | `keys("*")`        | `KEYS *`        | **谨慎使用！** 返回匹配给定模式的所有键。`*` 通配所有。在生产环境中可能阻塞服务。 |
| **判断键是否存在** | `hasKey("name")`   | `EXISTS name`   | 检查指定键是否存在。返回布尔值。                             |
| **获取键的类型**   | `type(key)`        | `TYPE key`      | 返回键所存储的值的类型（string, list, hash, set, zset）。    |
| **删除键**         | `delete("mylist")` | `DEL mylist`    | 删除一个或多个指定的键及其对应的值。                         |





## 项目

### 1.HttpClient

#### 1.1简介

![image-20250921112655181](../AppData/Roaming/Typora/typora-user-images/image-20250921112655181.png)

#### 1.2入门语法

**Get基本方法**

```java
@Test
public void testGET() throws Exception {
    // 创建httpclient对象
    CloseableHttpClient httpClient = HttpClients.createDefault();
    // 创建请求对象
    HttpGet httpGet = new HttpGet("http://localhost:8080/user/shop/status");
    // 发送请求，接受响应结果
    CloseableHttpResponse response = httpClient.execute(httpGet);
    // 获取服务端返回的状态码
    int statusCode = response.getStatusLine().getStatusCode();
    System.out.println("服务端返回的状态码为：" + statusCode);
    HttpEntity entity = response.getEntity();
    String body = EntityUtils.toString(entity);
    System.out.println("服务端返回的数据为：" + body);
    // 关闭资源
    response.close();
    httpClient.close();
}
```





**Post基本方法**

```java
@Test
public void testPOST() throws Exception {
    // 创建httpclient对象
    CloseableHttpClient httpClient = HttpClients.createDefault();
    // 创建请求对象
    HttpPost httpPost = new HttpPost("http://localhost:8080/admin/employee/login");
    
    JSONObject jsonObject = new JSONObject();
    jsonObject.put("username", "admin");
    jsonObject.put("password", "123456");
    
    StringEntity entity = new StringEntity(jsonObject.toString());
    // 指定请求编码方式
    entity.setContentEncoding("utf-8");
    // 数据格式
    entity.setContentType("application/json");
    httpPost.setEntity(entity);
    
    // 发送请求
    CloseableHttpResponse response = httpClient.execute(httpPost);
    
    // 解析返回结果
    int statusCode = response.getStatusLine().getStatusCode();
    System.out.println("响应码为：" + statusCode);
    
    HttpEntity entity1 = response.getEntity();
    String body = EntityUtils.toString(entity1);
    System.out.println("响应数据为：" + body);
    
    //关闭资源
    response.close();
    httpClient.close();
}
```





















# 自己项目

## AIServer

### 1.项目启动

```json
//http://localhost:8080/ques/getQues

// 启动：  uvicorn RunAPP:app --reload

{

  "userId":1,

  "talkId":1,

  "question":"我四肢抽搐这是什么疾病？"

}
----------------------------------------------------------------
{

 	"question":"我还口吐白沫这是什么疾病？",

 	"round": 2,

  	"all_info":""

}
----------------------------------------------------------------
{

	"name":"darkside",

	"password":"123456"

}
```



### 2.技术

#### 2.1restTemplate.postForObject()

**方法作用**

1. **发送POST请求**：向指定的URL（`aiApiUrl`）发送一个HTTP POST请求。
2. **传递请求体**：将`request`对象（这里是`Map<String, Object>`）自动序列化为JSON格式作为请求体。
3. **处理响应**：将服务器返回的JSON响应自动反序列化为`AiResponse.class`类型的Java对象

```java
    private AiResponse callFastAPI(String question, String preAnswer) {
        try {
            Map<String, Object> request = new HashMap<>();
            request.put("question", question);
            request.put("round", 2);
            request.put("all_info", preAnswer);

            // 直接返回完整响应对象（包含result和summary）
            return restTemplate.postForObject(aiApiUrl, request, AiResponse.class);

        } catch (Exception e) {
            e.printStackTrace();
            // 异常时返回默认响应对象
            AiResponse errorResponse = new AiResponse();
            errorResponse.setResult("调用AI模型时发生错误: " + e.getMessage());
            errorResponse.setSummary("");
            return errorResponse;
        }
    }
```



















# git使用

## 简介

![image-20250829120800529](../AppData/Roaming/Typora/typora-user-images/image-20250829120800529.png)

## 创建仓库

![image-20250829135222259](../AppData/Roaming/Typora/typora-user-images/image-20250829135222259.png)

### 整个流程

![image-20250829142747243](../AppData/Roaming/Typora/typora-user-images/image-20250829142747243.png)

## 指令

### 简单总结

![image-20250829160022322](../AppData/Roaming/Typora/typora-user-images/image-20250829160022322.png)

### 配置信息

![image-20250829131958526](../AppData/Roaming/Typora/typora-user-images/image-20250829131958526.png)

![image-20250710115233995](../AppData/Roaming/Typora/typora-user-images/image-20250710115233995.png)

### 查看提交日志



![image-20250829141827428](../AppData/Roaming/Typora/typora-user-images/image-20250829141827428.png)

![image-20250829142302250](../AppData/Roaming/Typora/typora-user-images/image-20250829142302250.png)

### 查看操作记录

![image-20250829142613385](../AppData/Roaming/Typora/typora-user-images/image-20250829142613385.png)





### 快捷方式

git-log

![image-20250710121123948](../AppData/Roaming/Typora/typora-user-images/image-20250710121123948.png)

### 版本回退

![image-20250710121406084](../AppData/Roaming/Typora/typora-user-images/image-20250710121406084.png)

### 分支

#### 基本方法



![image-20250710140500870](../AppData/Roaming/Typora/typora-user-images/image-20250710140500870.png)

![image-20250710141220236](../AppData/Roaming/Typora/typora-user-images/image-20250710141220236.png)

#### 合并

将dev01合并到当前分支

![image-20250829145657676](../AppData/Roaming/Typora/typora-user-images/image-20250829145657676.png)

#### 合并冲突

![image-20250710142057138](../AppData/Roaming/Typora/typora-user-images/image-20250710142057138.png)

#### 分支标准化使用

![image-20250829153207406](../AppData/Roaming/Typora/typora-user-images/image-20250829153207406.png)

![image-20250710144008650](../AppData/Roaming/Typora/typora-user-images/image-20250710144008650.png)

#### 删除分支

![image-20250710144435006](../AppData/Roaming/Typora/typora-user-images/image-20250710144435006.png)

## 如何推送到github

假设你的 GitHub 用户名是 **`DarksideCasria`**，你的远程仓库名是 **`myProject`**，本地主分支是 **`main`**。



### 总结：将本地代码推送到 GitHub 的方法



将本地代码推送到 GitHub 的基本流程包括三个核心步骤：**本地代码的提交**，**与远程仓库的关联**，以及**最终的推送**。



#### 步骤一：本地仓库准备与提交



1. **初始化 Git 仓库**：在你的项目文件夹 (`/d/pycharmProject/MedicalRAG`) 中，打开命令行并运行以下命令，将这个文件夹初始化为一个 Git 仓库。

   Bash

   ```
   git init
   ```

   这个命令会在你的项目目录下创建一个隐藏的 `.git` 文件夹。

2. **添加并提交文件**：

   - **首先，确保你已创建 `.gitignore` 文件**，并忽略了如 `__pycache__`、`.idea`、`chroma_db` 等不应被追踪的文件夹。
   - 接下来，将所有文件添加到暂存区并进行第一次提交。

   Bash

   ```
   git add .
   git commit -m "Initial commit of project"
   ```

------



#### 步骤二：与远程仓库关联



在 GitHub 上创建一个名为 `myProject` 的空仓库。然后，选择以下两种方法之一，将本地仓库与这个远程仓库关联起来。

**方法一：使用 HTTPS 协议 (简单但有时不稳定)**

Bash

```
git remote add origin https://github.com/DarksideCasria/myProject.git
```

**方法二：使用 SSH 协议 (推荐)**

在使用此方法前，**你必须先在 GitHub 账户中配置好你的 SSH 公钥**。配置完成后，使用这个命令：

Bash

```
git remote add origin git@github.com:DarksideCasria/myProject.git
```

------



#### 步骤三：推送代码到 GitHub



现在，你只需将本地提交的代码推送到远程仓库。

Bash

```
git push -u origin main
```

- `git push`：执行推送操作。
- `-u`：将本地 `main` 分支和远程 `origin` 上的 `main` 分支关联起来，这样以后你就可以直接使用 `git push` 和 `git pull` 了。
- `origin main`：指定要推送的远程仓库别名和本地分支名。

只要你的网络连接没有问题，执行这个命令后，你的本地代码就会被成功上传到 GitHub 仓库。

## 可能的问题

### 1. 识别问题



首先，我们确认了你遇到的根本问题：

- **问题一：** `git push` 失败，出现 `fatal: unable to access ... Connection was reset` 错误。这表明是网络连接问题。
- **问题二：** `git push` 失败，出现 `remote: error: File ... exceeds GitHub's file size limit` 错误。这表明你提交的文件超过了 GitHub 的 100MB 硬性限制。



### 2. 解决网络连接问题



为了解决 HTTPS 协议下不稳定的网络连接，我们采用了更可靠的 **SSH 协议**。

- **执行命令：**

  Bash

  ```
  git remote remove origin
  git remote add origin git@github.com:DarksideCasria/myProject.git
  ```

- **作用：** 这两步移除了你原有的远程仓库别名，并重新添加了一个使用 SSH 协议的别名，从而绕过了网络连接问题。



### 3. 解决文件过大问题



这是最复杂的一步。我们发现你的大文件已经进入了 Git 的提交历史。只使用 `.gitignore` 无法解决，因为 `.gitignore` 只对未被追踪的文件有效。因此，我们必须**重写 Git 历史**。

- **执行命令：** 我们使用了一个更强大的工具 `git filter-repo` 来从 Git 历史中永久性地移除大文件。

  Bash

  ```
  git filter-repo --path-glob 'chroma_db/' --invert-paths --force
  # 对其他大文件重复此操作，例如：
  git filter-repo --path-glob 'model_cache/' --invert-paths --force
  git filter-repo --path Data/documents/TT_book3/PDFsam_Final_all.pdf --invert-paths --force
  ```

- **作用：** 这些命令会扫描你的所有提交，并**彻底删除**这些指定的大文件，使得你的 Git 历史变得干净。`--force` 参数用于强制执行这个有风险的重写操作。



### 4. 再次推送



在重写历史后，你的本地 Git 仓库和远程 GitHub 仓库的历史不再匹配。因此，你必须使用强制推送。

- **执行命令：**

  Bash

  ```
  git push --force origin NeuroRAG
  ```

- **作用：** 这个命令告诉 Git 强制覆盖远程仓库的 `NeuroRAG` 分支，用你本地新的、不含大文件的历史来替代它。

最终，这个强制推送成功了，你的项目现在已经安全地上传到了 GitHub。通过这几个步骤，你不仅解决了当下的问题，还学习了 Git 中几个非常重要的概念：远程仓库、换行符差异、文件大小限制，以及历史重写。

### 5.这个端口一直不行就换成下面这个端口

我之前是20端口

git remote set-url origin ssh://git@ssh.github.com:443/你的用户名/你的仓库名.git

git remote set-url origin ssh://git@ssh.github.com:443/DarksideCasria/Scrapy_NCBI.git







## 修改后流程

我这样就行了

git remote set-url origin https://github.com/DarksideCasria/MedicalRAG.git（MedicalRAG是远程仓库名字）

git push -u origin master(master是当前分支名字)

实在不行先如下操作（先执行git remote add origin git@github.com:DarksideCasria/StudyProject.git操作）

git remote set-url origin ssh://git@ssh.github.com:443/DarksideCasria/Scrapy_NCBI.git



# 代码报错修改

## 1.MySQL

### 1.1启动时报错

![image-20250913201029346](../AppData/Roaming/Typora/typora-user-images/image-20250913201029346.png)

```
netstat -aon | findstr "3306"

taskkill /F /PID 上面MySQL输出的最后的数字
```

### 1.2这里被我修改过密码

改为了Gongyusong666

![image-20250914201834407](../AppData/Roaming/Typora/typora-user-images/image-20250914201834407.png)

## 2.SpringBoot

### 2.1IOC容器实例重复

**重复 Bean 定义**

- 你在 `AliOssUtil` 类上已经加了 `@Component`，Spring 默认已经会注册它。
- 现在又在配置类里 `@Bean` 再创建一次，可能造成冲突或者覆盖。



## 3.命令行窗口

### 3.1如何进入D盘

**方法一：**

```

C:\Windows\System32>cd /d D:\CodingAPP\Redis
```

**方法二：**

1. 首先输入盘符 `D:` 然后按回车，这样当前目录就会切换到 D 盘的当前目录（通常是根目录）。

   cmd

   ```
   D:\>D:
   ```

   

2. 然后使用 `cd` 命令进入 CodingAPP 文件夹。

   cmd

   ```
   D:\>cd CodingAPP
   ```

   

   完成后，您的命令行提示符就会变成 `D:\CodingAPP>`。

















